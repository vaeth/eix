.TH "eix" "1" "" "@PACKAGE_STRING@" ""
.\" {{{ NAME
.SH "NAME"
.B eix
- Programme zum Durchsuchen, Vergleichen und Updaten eines Binärcaches der lokalen Portagebaums
.\" }}}

.\" {{{ Übersicht
.SH "ÜBERSICHT"
.B eix
[I<gemeinsame Optionen>] [I<OPTIONEN>] I<AUSDRUCK>

.B eix-update
[I<gemeinsame Optionen>] [I<eix-update-OPTIONEN>]

.B eix-diff
[I<gemeinsame Optionen>] [I<ALTER-CACHE>] [I<NEUER-CACHE>]

.B eix-sync

.B eix-postsync

.B eix-test-obsolete

.B eix-remote

.B eix-installed-after

.B eix-installed

.B eix-etcat

.B eix-functions.sh

.B eix-header

.B eix-drop-permissions
[B<-->] [I<Befehl zum Ausführen>]

.B masked-packages
I<Kategorie>B</>I<Name>B<->I<Version>[B<:>I<Slot>][B<::>I<Repo>]

.B versionsort
[B<-n>|B<-p>|B<-f>|B<-v>|B<-r>|B<-V>] [I<(Müll)>I<Paket->]I<Version> ...
.\" }}}

.\" {{{ BESCHREIBUNG
.SH "BESCHREIBUNG"
B<eix-update> generiert einen Binärcache des lokalen Portagebaums und von Overlays.
B<eix> durchsucht diesen Cache nach Paketen, die Kriterien erfüllen, die durch I<AUSDRUCK> festgelegt werden;
falls auf der Kommandozeile kein einschränkendes Kriterium angegeben wird, werden natürlich alle Pakete ausgegeben.
B<eix-diff> vergleicht zwei solcher Binärcache und gibt Pakete aus, die hinzugefügt oder entfernt wurden, oder für
die sich die höchste stabile Versionsnummer geändert hat.

Alle zugehörigen Programme und Skripte lesen die später beschrieben Konfigurationsfiles.
B<eix-sync> hat optional eine separate Konfigurations-Datei.

B<eix-sync> kann den Portage/Overlay-Baum syncen und vergleicht ihn mit dem alten Cache (vermöge B<eix-diff>).
Mehr über B<eix-sync> erfahren Sie durch den Aufruf B<eix-sync -h> und in der untenstehenden
Beschreibung von I<@SYSCONFDIR@/eix-sync.conf>.
Beachten Sie, dass der Inhalt dieser Datei auch in der Variablen B<EIX_SYNC_CONF> gespeichert werden kann.

B<eix-postsync> ist eine einfache Alternative zu B<eix-sync>.
Es ist ähnlich wie B<eix-update>, erzeugt aber zuvor ein Backup der Cache-Datei,
so dass B<eix-diff> benutzt werden kann, um die Unterschiede zum vorherigen
Syncen zu zeigen.
Um B<eix-postsync> automatisch nach <emerge --sync> aufzurufen,
kann man für >=portage-2.3.7 das Verzeichnis /etc/portage/postsync.d/ erzeugen
und dort einen symbolischen Link auf B<eix-postsync> platzieren.
Der Hauptnachteil von B<emerge --sync> mit diesem Link (im Vergleich zu B<eix-sync>)
ist, dass für den Ausnahmefall, dass ein Upgrade von eix die alte Datenbank
nicht mehr unterstützt, B<eix-diff> für das erste Syncen nach dem Upgrade
nicht funktioniert (außer man ruft manuell B<eix-update> vor dem Syncen auf).

B<eix-test-obsolete> ist ein Skript, das B<eix> mehrmals aufruft, um die Ausgabe von B<eix -tTc> besser organisiert auszugeben.

B<eix-remote> kann eine Eix-Datenbank von einem externen Server syncen und ihn zum
lokalen Cache hinzufügen und wieder entfernen.
Dies kann verwendet werden, um eine lokale Datenbank mit Paketen in allen registrierten Repositorys/Overlays zu erstellen, nicht nur denen in lokal installierten Overlays.
Falls nicht anders konfiguriert, benutzt es ein separates Datenbankfile.
Bei dieser Vorgabe sollten Sie regelmäig B<eix-remote add1> und/oder <eix-remote add2> nach <eix-update>
aufrufen, so dass das separate Cachefile mit der Hauptdatenbank synchron ist.
(Bei Benutzung von B<eix-sync> geschieht dies per Default.)
Falls das selbe Datenbankfile benutzt wird, können Remote-Daten über
B<eix-update>-Aufrufe hinweg erhalten werden, wenn Sie B<KEEP_VIRTUALS=true> in I<@SYSCONFDIR@/eixrc> setzen.
Per Standardeinstellung wird dieses Skript seine Rechte durch B<eix-drop-permissions> fallenlassen.
Mehr zu B<eix-remote> erfahren Sie durch den Aufruf B<eix-remote -h>.

B<eix-installed-after> ist ein einfaches Skript (mit vielen Kommentaren),
das einige Möglichkeiten aufzeigt, wie eine vom Skript angepasste eix-Ausgabe genutzt werden kann:
Das Skript gibt diejenigen Pakete aus, die nach (oder vor) dem letzten (oder ersten) Emerge eines
spezifizierten Pakets/Version installiert wurden.
Mehr zur Benutzung erfahren Sie durch den Aufruf B<eix-installed-after -h>.

B<eix-functions.sh> gibt Hilfsfunktionen aus, die von B<eix-sync> und B<eix-remote>
benutzt werden und die in ähnlichen Skripten benutzt werden können.
Man sollte die Ausgabe des Programms mit "eval" verarbeiten.
Beachten Sie, dass unmittelbar danach normalerweise zur Initialisierung
B<ReadFunctions> aufgerufen werden muss.

B<eix-header> ist ein Hilfsprogramm für B<eix-remote> (und möglicherweise eigene Skripte).
Es kann Datenbankdatei-Köpfe überprüfen und Overlay-Pfade oder -Labels aus diesen Dateien
finden oder ausgeben.
Eine detailliertere Beschreibung erhalten Sie mit B<eix-header -h>.

B<eix-drop-permissions> ist ein Hilfsprogramm für B<eix-remote> (und möglicherweise eigene Skripte).
Es führt das im Argument angegebene Kommando mit eingeschränkten Rechten aus.
Die Einschränkung wird durch B<EIX_USER>, B<EIX_GROUP>, B<EIX_UID>, B<EIX_GID> (siehe später) spezifiziert.
Beachten Sie, dass auch die Binärprogramme B<eix>, B<eix-diff> und B<eix-update> ihre
Rechte so früh wie möglich gemäß diesen Variablen einschränken, d.h. es kann nötig sein,
diese Variablen anzupassen, falls B<eix> (insbesondere B<eix-update>)
in einem Nichtstandard-Setting genutzt werden soll.

B<eix-installed> ist ein einfaches Skript, das alle installierten Pakete (und ihre exakte Version)
ausgibt, und das prüfen kann, welche Pakete mit/ohne Repository- oder Buildtime-Information gebaut wurden
(vgl. die Beschreibung zu B<CHECK_INSTALLED_OVERLAYS> und B<USE_BUILD_TIME>).
Mehr zu B<eix-installed> erfahren Sie durch den Aufruf B<eix-installed -h>.

B<eix-etcat> ist ein Wrapper-Skripts, das eix mit einer Konfiguration aufruft,
so dass das Verhalten ähnlich dem von B<etcat -v> aus alten
app-portage/gentoolkit Versionen oder dessen aktuelle Version von
https://github.com/proteusx/etcat/ (z.B. app-portage/etcat aus dem mv overlay) ist.
Die Ausgabe ist analog, und die voreingestellte Eingabe akzeptiert eine Folge
von Paketnamen (die Angabe der Kategorie ist optional).
Es kann lehrreich sein, sich das einfache Wrapper-Skript anzusehen, wenn man
ein eigenes Eingabe-/Ausgabeformat schreiben will: Das Ausgabeformat erhält
man durch den Aufruf von B<eix --print FORMAT_ETCAT> und
B<eix --print FORMAT_VERSION_ETCAT>.

B<masked-packages> ist ein Hilfsprogramm für Skripte, das die Argumente gegen
eine Maskenliste testet.
Details stehen nahe am Ende dieser Manpage.

B<versionsort> ist ein Hilfsprogramm für Skripte, das die Versionsnummer von
den Argumenten abtrennt, und das die gefundenen Versionsnummern gemäß den
Portage-Regeln sortiert.
Details stehen nahe am Ende dieser Manpage.
.\" }}}

.\" {{{ OPTIMIERUNG, SPEICHER, SICHERHEIT
.SH "OPTIMIERUNG, SPEICHER, SICHERHEIT"
Wenn Sie eix vom gentoo repository installiert haben, dann wird das eix ebuild
sehr wahrscheinlich B<nicht> die B<CXXFLAGS> und B<LDFLAGS> benutzt haben,
die der Maintainer von eix zur Optimierung und Sicherheit empfiehlt.
Zudem kann eix bei Bedarf so konfiguriert werden, dass es weniger Speicher benötigt.
Lesen Sie daher bitte den Abschnitt B<INSTALLATION>, um zu erfahren, wie der
Maintainer von eix die Installation empfiehlt.
.\" }}}

.\" {{{ BEISPIELE
.SH "BEISPIELE"

Die folgenden Beispiele sind nützliche aber vielleicht untypische Anwendungen von eix.
Sie werden hier aufgelistet, um eine Idee davon zu geben, welche unerwarteten Dinge mit eix mit möglich sind.
Da diese Beispiele mit cut-and-paste von dieser Seite kopiert werden sollten, sind sie gleich
zu Anfang aufgelistet.
Um zu verstehen, wie sie funktionieren, ist es natürlich notwendig, die vollständige  Manpage zu lesen.
Weitere Beispiele finden Sie beispielsweise im Skript B<eix-installed-after>, das viele Kommentare enthält.

.TP
.IB cmd " | eix '-|*' --format '<markedversions:NAMESLOT>'"

Falls I<cmd> eine Liste der Gestalt B<Kategorie/Name-Version> or B<=Kategorie/Name-Version>
 ausgibt, gibt das obige Kommando die entsprechende List B<Kategorie/Name> oder B<Kategorie/Name:SLOT> aus
(je nachdem, ob die B<SLOT>s unterschieden werden müssen).

.TP
.IB cmd " | eix '-|*' --format '<markedversions:NAMEASLOT>'"

Ähnlich wie eben, aber es wird immer B<Kategorie/Name:SLOT> ausgeben,
selbst wenn B<SLOT> redundant ist. (Mnemonic: B<A>lways).

.TP
.B eix '-I*' --format '<installedversions:NAMEVERSION>'

Gibt die installierten Pakete im Format B<Kategorie/Name-Version> aus.
Natürlich kann man B<NAMEVERSION> auch durch B<NAMESLOT> oder B<NAMEASLOT> ersetzen,
um ein anderes Format zu erhalten.
Der einzige Zweck der Option B<I> in diesem Zusammenhang ist eine geringfügige Beschleunigung der Ausgabe.

.TP
.B eix '-I*' --format '<installedversions:EQNAMEVERSION>'

Ähnlich wie eben, aber im Format B<=Kategorie/Name-Version>,
das direkt von Portage benutzt werden kann.

.TP
.B eix '-I*' --format '<installedversions:DATESORT>' | sort -n | cut -f2-3

Gibt die installierten Pakete (falls notwendig mit Slots) aus, sortiert nach Installationsdatum.
Zur Ausgabe in einem anderen Format kann B<DATESORT> entsprechend modifiziert werden
(die ursprüngliche Definition steht in der Ausgabe von B<eix --dump>).

Das Sortieren funktioniert folgendermaßen: Die B<DATESORT>-Variable gibt als
erste Spalte die Sekunden seit Epoch aus (Mit B<eix --print DATESORT> erfahren Sie,
dass dies durch die Variable B<DATESORT_DATE> geschieht, deren erster Eintrag B<%s> lautet),
und B<sort> erzeugt so durch einfaches alphabetisches Sortieren die korrekte Ordnung.
Das B<cut>-Kommando verschluckt schließlich wieder die erste Spalte, die nur zum Sortieren benötigt wurde.

.LP
In diesen Beispielen sind Dinge wie B<NAMEVERSION> oder B<DATESORT> nur Variablennamen,
die in eix vordefiniert wurden (B<eix --dump> listet sie auf).
Genausogut können natürlich auch eigene Variablen definiert und benutzt werden.
Genaueres dazu steht später in der Manpage, insbesonder die Beschreibung des B<FORMAT> Strings.
.\" }}}

.\" {{{ OPTIONEN
.SH "OPTIONEN"
.\" {{{ -------- gemeinsame Optionen
.SS gemeinsame Optionen
Die folgenden Optionen sind B<eix>, B<eix-diff> und B<eix-update> gemein:
.TP
.BR -h ", " --help
Ausgabe eines Hilfstextes und Ende.
.TP
.BR -Q ", " --quick "   (toggle)    (nicht für B<eix-update>)"
Verhindert/Ermöglicht, dass Slots installierter Versionen gelesen werden,
die nicht vermutet werden können (d.h. installierter Versionen von Paketen
mit mindestens zwei verschiedene Slots, für die die installierte Version
nicht mehr in der Datenbank ist).
Beachten Sie, dass mit dieser Option eix und eix-diff falsche Posittreffer
über Up-/Downgrade-Empfehlungen für diese Pakete ausgeben könnten.
.TP
.BR --care "    (nicht für B<eix-update>)"
Deaktiviert B<--quick>, und darüberhinaus werden Slots installierter Versionen
immer gelesen, auch dann wenn der Slotname vermutet werden kann.
Dies stellt insbesondere sicher, dass Up-/Downgrade-Empfehungen auch dann
ausgegben werden, wenn sich der Slotname einer installierten Version ändert.
Beachten Sie, dass diese Option die Geschwindigkeit beim ersten Aufruf
dramatisch reduziert. (Wenn das Dateisystem einen vernünftigen Cache hat,
werden spätere Aufrufe kaum langsamer sein als ohne diese Option).
.TP
.BR --deps-installed  "    (nicht für B<eix-update>)"
Dies ist das selbe wie B<DEPS_INSTALLED=true>.
Abhängigkeiten installierter Versionen werden immer gelesen,
auch dann, wenn sie von verfügbaren Versionen bekannt ist.
Beachten Sie, dass diese Option die Geschwindigkeit beim ersten Aufruf
dramatisch reduziert. (Wenn das Dateisystem einen vernünftigen Cache hat,
werden spätere Aufrufe kaum langsamer sein als ohne diese Option).
.TP
.BR -q ", " --quiet "   (toggle)"
Ausgaben auf stdout werden verhindert.
Für eix kann ggf. die Ausführungszeit weiter reduziert werden, wenn diese
Kombination mit (je nach Einsatzzweck) entweder B<--brief> oder B<--brief2>
kombiniert wird, und durch Setzen von B<COUNT_ONLY_PRINTED=false>.
Siehe auch B<NOFOUND_STATUS> und B<MOREFOUND_STATUS>
.TP
.B --dump
Ausgabe der aktuellen eixrc-Variablen und ihrer Vorgabewerte als Kommentar; dann Ende.
.TP
.B --dump-defaults
Ausgabe der Vorgabewerte der eixrc-Variablen und ihrer aktuellen Werte als Kommentar; dann Ende.
.TP
.BI "--print " VAR
Ausgabe der spezifizierten Variablen I<VAR> aus eixrc oder der Portage-Konfiguration; dann Ende.
Die Ausgabe erfolgt vollständig expandiert, so wie sie intern von eix benutzt würde.
Der Exit-Status ist positiv, falls I<VAR> eix unbekannt ist (siehe B<--known-vars>).
Diese Option ist hauptsächlich für Skripte nützlich oder zum Debuggen.
Zur Benutzung in Skripten empfiehlt sich die Benutzung von B<PRINT_APPEND>.
um das Abschneiden von Leerzeichen am Ende zu verhinden (siehe die Beschreibung zu B<PRINT_APPEND>).
Zwei spezielle I<VAR>-Werte, die man nur auf diese Weise erhalten kann,
sind B<USE.profile> und B<USE.make_conf>, die den USE-String des Profiles
bzw. von make.conf vor dem Aneinanderhängen enthalten.
.TP
.B --known-vars
Ausgabe eine alphabetischen Liste aller Variablen, die eix für B<--print> bekannt sind.
Nach jedem Variablennamen wird ein Zeilenumbruch ausgegeben.
.TP
.BR -V ", " --version
Ausgabe der Versionsnummer und Ende.
.TP
.BR -n ", " --nocolor
Verhindert die Ausgabe von ANSI Farbcodes;
nützlich für Terminals, die diese nicht kennen.
(Dies wird automatisch aktiv, falls stdout nicht auf ein tty führt, kann aber mit --force-color überschrieben werden).
.TP
.BR -F ", " --force-color
Das Gegenteil von --nocolor.
.\" }}}

.\" {{{ -------- eix ausschließend
.SS Spezielle Informations-Optionen
Die folgenden speziellen Informations-Optionen versteht nur das eigentliche B<eix>-Programm.
Sie sind einmalig und ausschließend, d.h. eix gibt nur die entsprechenden Daten aus und beendet sich dann.
.TP
.BR --color " " (always / never / auto)
Überschreibt alle anderen Farboptionen und Variablen:
Gibt Farben immer, nie, bzw. nur bei Ausgabe auf ein Terminal aus.
.TP
.BR --ansi " (auch für eix-diff)"
Legt die 256-Farbpalette von Todd Larason fest (dem Author des 256-Farbsupports für xterm).
Benutzen Sie diese Option, wenn ein Tool die normalerweise eingestellte Palette umdefiniert hat.
.TP
.BR "--256" ", " "--256f" ", " "--256f0" ", " "--256f1" ", " "256b"
Print the 256 color palettes (assuming it follows ansi color scheme) and exit.
With B<--256d>/B<--256l> (B<--256d0>/B<--256l0>, B<--256d1>/B<--256l1>) only the foreground palettes with dark/light background
(or only the normal or bright dark/light foreground palette, respectively) is printed.
With B<--256b> only the background palette is printed.
.BR "--256" ", " "--256f" ", " "--256f0" ", " "--256f1" ", " "256b"
Ausgabe der 256-Farben-Paletten unter der Annahme, dass sie dem Ansi-Farbschema folgt; danach Programmende.
Mit B<--256d>/B<--256l> (B<--256d0>/B<--256l0>, B<--256d1>/B<--256l1>) werden nur die Vordergrund-Farbpaletten mit dunklem/hellem Hintergrund ausgegeben
(bzw. nur die normale oder fette Vordergrund-Farbpalette mit dunklem/hellen Hintergrund).
Mit B<--256b> wird nur die Hintergrundfarbpalette ausgegeben.
.TP
.B --print-all-eapis
Gibt alle IUSE- oder EAPIs aus, die in irgendeiner Version benutzt werden.
.TP
.B --print-all-useflags
Gibt alle IUSE- oder REQUIRED_USE-Worte aus, die in irgendeiner Version benutzt werden.
.TP
.B --print-all-keywords
Gibt alle KEYWORDS aus, die in irgendeiner Version benutzt werden.
.TP
.B --print-all-slots
Gibt alle SLOT-Strings aus, die in irgendeiner Version benutzt werden.
.TP
.B --print-all-licenses
Gibt alle LICENSE-Strings aus, die in irgendeiner Version benutzt werden.
.TP
.B --print-all-depends
Gibt alle Worte aus, die in einem B<{,R,P,B}DEPEND> auftauchen.
Dies geht nur, falls B<DEP=true> aktiv ist (und bei der Erzeugung der Cachedatei aktiv war).
.TP
.B --print-world-sets
Gibt die world sets aus.
.TP
.B --print-profile-paths
Gibt alle Pfade des aktuellen Profils aus.
An jeden Pfad wird B<PRINT_APPEND> angehängt.
Falls B<PRINT_APPEND> leer ist, wird das Nullzeichen angehängt.
.\" }}}

.\" {{{ -------- Ausgabe-Optionen
.SS Ausgabe-Optionen
.TP
.BR --nowarn "   (toggle)"
Unterdrückt einige Warnungen bzgl. der Portage-Konfiguration
.TP
.BR -x ", " --versionsort "    (toggle)"
Gibt die vorhandenen Versionen sortiert nach Versionen (oder Slots) aus.
Bei Slot-sortierter Ausgabe wird jeder Slot in einer neuen Zeile ausgegeben.
Dieser Modus kann mit B<--versionlines> (B<-l>) kombiniert werden,
um für jede neue Version eine neue Zeile auszugeben.
.TP
.BR -l ", " --versionlines "   (toggle)"
Gibt die vorhandenen Versionen in einer (vertikalen) Liste aus.
Nur in diesem Modus werden gewisse Zusatzinformationen für jede Version ausgegeben.
Genauer, je nachdem ob B<--verbose> benutzt wird und abhängig vom Status der
Konfigurationsvariablen B<VERSION_{IUSE,KEYWORDS,DEPS}_{NORMAL,VERBOSE}>
kann dies B<KEYWORDS>, B<IUSE>, B<DEPEND>, B<RDEPEND>, B<PDEPEND>, B<BDEPEND>, B<IDEPEND> sein.
Beachten Sie: Falls B<IUSE> nicht für jede Version ausgegeben wird, so wird es
nur gesammelt für das gesamte Paket ausgegeben, was einen falschen Eindruck geben kann,
da sich B<IUSE> von Version zu Version zuweilen dramatisch ändert.
.TP
.BR -c ", " --compact
Wählt ein kompaktes Layout für die Ausgabe von Suchergebnissen.
Nützlich, um einen besseren Überblick über eine lange Ergebnisliste zu erhalten,
und es hilft auch, die Suche über eine lansame Verbindung (wie etwa eine serielle Konsole)
zu beschleunigen.
.TP
.BR -v ", " --verbose
Benutzt ein ausführliches Layout mit zusätzlichen Informationen über Suchergebnisse
(wie etwa die Lizenz eines Pakets).
.TP
.BR -N ", " --normal
Benutzt das normale Layout, das der Default ist, wenn B<DEFAULT_FORMAT> nicht
ausdrücklich anders gesetzt wurde.
.TP
.BR --xml ", " --proto "   (toggle)"
Ausgabe im XML- oder Protobuf-Format.

Für Benutzung druch ein externes Programm empfiehlt sich zusätzlich
die Benutzung von B<--care>.

Für B<--xml> empfiehlt sich zusätzlich das Exportieren von
B<LOCAL_PORTAGE_CONFIG> um sicherzustellen, dass die Benutzereinstellung die
Ausgabe nicht beeinflusst

Das Format von B<--proto> hängt nicht von dieser Variablen ab: Lokale und System-Einstellungen sind getrennt.

Mit diesen Optionen werden B<OVERLAYS_LIST=none> und B<--pure-packages>
automatisch aktiviert.

Das Ausgabeformat für B<--xml> kann minimal mit den B<XML_*>-Variablen beeinflusst werden.
Das benutzte XML-Format ist auf menschenlesbare Art in den Dateien eix-xml.html oder eix-xml.txt
dokumentiert und auf weniger menschenlesbare Art (nämlich als XML-Schema) in der Datei eix-xml.xsd.

Das Protobuf-Format ist durch die Datei eix.proto festgelegt.
.TP
.BR -* ", " --pure-packages "   (toggle)"
(bei der Benutzung der Kurzform in einer Shell bitte das Quoten nicht vergessen!)
Diese Option verhindert die Ausgabe zusätzlicher Informationen (Overlaynamen, Zahl der gefundenen Pakete) am Ende.
Dies kann für Shellskripte nützlich sein, die die Ausgabe parsen.
.TP
.BR -# ", " --only-names "   (toggle)"
Wie B<--pure-packages>, aber zusätzlich werden nur Kategorie und Name der gefundenen Pakete ausgegeben.
.TP
.BR -0 ", " --brief "   (toggle)"
Ausgabe von höchstens einem Paket.
Diese Option ist normalerweise schneller, wenn sie mit B<COUNT_ONLY_PRINTED=false> kombiniert wird.
In diesem Fall und zusammen mit Fuzzy-Suche wird nicht notwendigerweise der beste Treffer ausgegeben.
.TP
.BR --brief2 "   (toggle)"
Wie B<--brief>, aber Ausgabe von bis zu zwei Paketen.
.\" }}}

.\" {{{ -------- Optionen für eix
.SS Spezielle Optionen für B<eix>
.TP
.BR -t ", " --test-non-matching
Vor anderer Ausgabe werden Einträge in /etc/portage/package.* ausgegeben,
die kein passendes Pendant in der Paketdatenbank haben, oder die offensichtlich
keine Bedeutung haben, weil sie leer sind (siehe B<TEST_FOR_EMPTY>).

Diese Option listet ebenfalls alle installierten Pakete, deren Name nicht
in der Datenbank zu finden ist.

Dies ist etwas prinzipiell anderes als B<-T> (siehe unten).
Das letztere überprüft nur für Pakete B<in der Datenbank>, ob redundante
Einträge in /etc/portage/package.* existieren bzw. ob die installierten Versionen
vorhanden sind.

Am besten wird diese Option mit B<-T> kombiniert, um /etc/portage/package.* aufzuräumen.

Oder sie kann mit B<-e> kombiniert werden, um weitere Ausgaben zu verhindern.

Falls es einen Grund gibt, bestimmte Einträge/Pakete von diesem Test auszuschließen,
können diese Einträge in eine Datei /etc/portage/package.*.nonexistent eingefügt werden.
Hier steht B<*> für eines der Worte B<accept_keywords> (oder das
obsolete B<keywords>), B<mask>, B<unmask>, B<use>, B<env>, B<license>,
B<accept_restrict>, B<cflags> oder B<installed>.
Diese Dateien (und wie ihre Namen geändert werden können) wird später beschrieben.

.TP
.BR -R ", " --remote
Benutzt den Wert von EIX_REMOTE1 als Namen für das Cachefile.
Diese Option sollten Sie benutzen, wenn Sie Pakete im Cache sehen möchten, die von B<eix-remote> erstellt und synchronisiert wurden.
Sie können diese Option als Standardeinstellung aktivieren, indem Sie B<REMOTE_DEFAULT=1> setzen.

.TP
.BR -Z ", " --remote2
Benutzt den Wert von EIX_REMOTE2 als Namen für das Cachefile.
Diese Option sollten Sie benutzen, wenn Sie Pakete im Cache sehen möchten, die von B<eix-remote> erstellt und synchronisiert wurden.
Sie können diese Option als Standardeinstellung aktivieren, indem Sie B<REMOTE_DEFAULT=2> setzen.

.TP
.BI "--cache-file " FILE
Benutzt I<FILE> statt B<@EIX_CACHEFILE@>.

.\" {{{ -------- Optionen für AUSDRUCK
.SS Optionen für AUSDRUCK
AUSDRUCK wird benutzt um die Suche zu spezifizieren.

Ein AUSDRUCK kann Boolesche Operatoren und Tests gemäß der folgenden Grammatik enthalten:

AUSDRUCK ::= [ B<--not> | B<-!> ] KLAMMER_ODER_TEST |
               AUSDRUCK [ B<--and>| B<-a> ] AUSDRUCK |
               AUSDRUCK [ B<--or> | B<-o> ] AUSDRUCK

KLAMMER_ODER_TEST ::= B<--open>|B<-(> AUSDRUCK B<--close>|B<-)> |
               TEST_MIT_OPTIONEN

TEST_MIT_OPTIONEN ::= [TEST_OPTIONEN] [SUCHMUSTER]

Bitte vergessen Sie nicht, dass B<!>, B<(>, B<)> in Shells normalerweise gequotet werden müssen,
damit eix sie als Teil des Arguments erhält!

Falls ein AUSDRUCK mit B<-> beginnen soll, stellen Sie einfach zwei weiter B<--> Zeichen davor:
Auf diese Weise wird der AUSDRUCK nicht als Option interpretiert und zwei zusätzliche B<--> Zeichen werden ignoriert.
Beispielsweise wird B<eix ---tool --or ---util> diejenigen Pakete ausgeben die B<-tool> or B<-util> enthalten.

Die Bedeutung der logischen Operatoren sollte mit folgenden Ausnahmen offensichtlich sein:

1. Falls weder B<--and>|B<-a> noch B<--or>|B<-o> zwischen zwei AUSDRÜCKEN auftauchen,
so wird eines von beiden implizit angenommen.
Ob dies B<-a> oder B<-o> ist, hängt vom Wert der Konfigurationsvariable B<DEFAULT_IS_OR> ab.

2. Die Operatoren B<-a> und B<-o> haben gleiche Bindungskraft und sind linksassoziativ.
Insbesondere liefert B<X -o Y -a Z> keinen Treffer, falls B<Z> keinen Treffer liefert.

3. B<--not>|B<-!> negiert nur das Ergebnis des unmittelbar folgenden KLAMMER_ODER_TEST.

4. Falls SUCHMUSTER weggelassen wird, ist die Vorgabe ein leeres SUCHMUSTER.
Beispielsweise wird B<eix> mit den Standardeinstellungen ohne Argument alle Pakete
ausgeben, da der leere String in jedem Namen enthalten ist.
Andererseits sollte B<eix -e> (normalerweise) nichts ausgeben,
da kein Paketname (I<exakt>) leer sein sollte.

5. Beachten Sie, dass die Syntax bedeutet, dass das SUCHMUSTER stets einen Ausdruck beendet.
TEST_OPTIONEN nach SUCHMUSTER beginnt immer einen neuen Ausdruck
(d.h. ein implizites B<--and> oder B<--or> wird eingefügt, je nach B<DEFAULT_IS_OR>).
Insbesondere hat B<eix -e foo> eine andere Bedeutung als B<eix foo -e>.
Letzteres bedeutet das selbe wie B<eix foo --and -e> or B<eix foo --or -e>,
je nach B<DEFAULT_IS_OR>.

6. Beachten Sie, dass TEST_OPTIONEN mehrere Optionen enthalten kann.
Diese werden alle zugleich angewendet, d.h. in gewissem Sinne werden diese
Optionen logisch geklammert und mit B<and> kombiniert (unabhängig von B<DEFAULT_IS_OR>).
Dies ist etwas zweideutig, da SUCHMUSTER weggelassen werden kann.
Diese Zweideutigkeit wird so aufgelöst, dass aufeinanderfolgende TEST_OPTIONEN stets als
ein Teil eines einzige TEST_MIT_OPTIONEN aufgefasst werden.
Beispielsweise werden in B<eix -I -O -e foo> alle Optionen als Teil eines einzigen I<AUSDRUCK> interpretiert
(nicht als vier I<AUSDRUCK>-Argumente wie es etwas bei B<eix -I '' -O '' -e '' foo> der Fall wäre).
Andererseits wird das B<--not> in B<eix -I --not -e> nicht dazu führen, dass die darauffolgende
TEST_OPTION B<-e> als Teil eines neuen I<AUSDRUCK>s verstanden wird.
Andere Optionen als TEST_OPTIONEN oder logische Optionen (wie B<-!>, B<-(>, B<-)>, B<-a>, B<-o>) werden diesbezüglich ignoriert.
Beispielsweise wird B<eix -I -c -e> nur einen I<AUSDRUCK> erzeugen, da B<-c>
weder eine TEST_OPTION noch eine logische Option ist und daher bei der
Interpretation von I<AUSDRUCK> keine Rolle spielt.

7. TEST_OPTIONEN kann Dinge wie den B<Match-Algorithmus> oder die B<Operandenwahl> festlegen.
Alle diese Dinge beziehen sich B<only> auf den aktuellen TEST_MIT_OPTIONEN;
insbesondere sind sie nur für das nächste B<SUCHMUSTER> aktiv.

Beachtne Sie ebenfalls, dass es neben dieser AUSDRUCK Syntax auch einen
anderen Weg zur impliziten (allerdings langsamen) Paketwahl aufgrund
anderer Kriterien gibt: Nämlich, indem man  B<FORMATSTRING> (siehe unten)
mit entprechenden Konditionalen versieht, so dass es einen leeren String
für ungewünschte Pakete ausgibt.

Es folgen die zulässigen TEST_OPTIONEN:
.TP
.BR -I ", " --installed
Findet nur installierte Pakete.
Benutzen Sie dies bitte nicht als Ersatz für B<eix-installed -a>
(oder B<qlist -ICv> oder B<equery>), da es nicht das selbe ist:
Pakete, die installiert aber nicht mehr im Portage Tree (oder einem Overlay) sind,
werden auf diese Weise nicht gelistet.
Andererseits sollten Sie solche Pakete ohnehin besser nicht haben
(es ist besser, diese Pakete in einen Overlay zu kopieren, falls sie irgendwann einmal reinstalliert werden müssen).
Um solche Pakete zu finden, kann B<eix -te> benutzt werden (oder B<eix -tI> um beides auszugeben),
aber dabei ist zu beachten, dass eix -t nicht die üblichen B<FORMAT> rules auf diese Pakete anwendet.
Dies sollte daher besser nicht in Skripten benutzt werden (falls Sie nicht genau wissen, was Sie da tun).

Falls Sie diese Option unbedingt als einen Ersatz für equery in Skripten benuzten wollen,
dann werden Sie sie vermutlich mit einem der folgenden Optionen kombinieren wollen:

.B --format --only-names

.B --format '<installedversions:NAMEVERSION>' --pure-packages

.B --format '<installedversions:EQNAMEVERSION>' --pure-packages

.B --format '<installedversions:NAMESLOT>' --pure-packages

.B --format '<installedversions:NAMEASLOT>' --pure-packages

.B --format '<installedversions:DATESORT>' --pure-packages
.TP
.BR -i ", " --multi-installed
Findet nur Pakete, die in mindestens zwei verschiedenen Versionen installiert sind.
Normalerweise bedeutet dies, dass die Versionen geslotted sind (zumindest zu dem Zeitpunkt, als sie installiert wurden).
.TP
.BR -d ", " --dup-packages
Findet nur doppelte Pakete,
beispielsweise, falls sys-foo/bar im offiziellen Portagebaum und im lokalen Overlay existiert.
Falls B<DUP_PACKAGES_ONLY_OVERLAYS> gesetzt ist (siehe unten), müssen die Pakete in verschiedenen lokalen Overlays liegen.
.TP
.BR -D ", " --dup-versions
Findet nur Pakete mit doppelten Versionen,
beispielsweise, wenn sys-foo/bar-0.2.1 im offiziellen Portagebaum und im lokalen Overlay existiert.
Falls B<DUP_VERSIONS_ONLY_OVERLAYS> gesetzt ist (siehe unten), müssen die Ebuilds in verschiedenen lokalen Overlays liegen.
.TP
.BR -1 ", " --slotted
Findet nur Pakete mit einem nichttrivialen Slot, d.h. wenn Slot nichtleer ist und verschieden von "0".
.TP
.BR -2 ", " --slots
Findet nur Pakete mit mindesten zwei verschiedenen Slots.
Anders als bei -1 wird hierbei ein Paket nicht gezeigt, falls nur ein Slot vorhanden ist, der z.B. den Slotnamen "4.3" trägt.
.TP
.BR -u ", " --upgrade ", " --upgrade+ ",  " --upgrade-
Findet nur Pakete, die zumindest eine Version aus einem Slot installiert haben,
die nicht die beste innerhalb des Slots ist.
Dies bedeutet normalerweise, dass ein Upgrade/Downgrade des Pakets notwendig ist.

Dieser Test berücksichtigt auch B<UPGRADE_TO_HIGHEST_SLOT> (siehe unten).

Für B<--upgrade+> oder B<--upgrade-> verhält sich der Test, als wenn B<LOCAL_PORTAGE_CONFIG> B<true> bzw. B<false> ist.
Andernfalls wird diese Entscheidung von B<UPGRADE_LOCAL_MODE> gefällt.

Falls Sie nur Pakete mit Downgrade-Empfehlung sehen wollen, können Sie
die später beschriebenen B<FORMATSTRING>-Features benutzen.
.TP
.BR --stable ", " --testing ", " --non-masked ", " --system ", " --profile
Findet nur Pakete, die zumindest eine Version haben, die stabil (und nicht-maskiert),
testing oder stabil (und nicht maskiert), nicht-maskiert, bzw. in @system oder @profile ist.
Falls mehrere dieser Optionen in einem Test kombiniert werden, muss die selbe Version
allen Kriterien genügen.
.TP
.BR --stable+ ", " --testing+ ", " --non-masked+ ", " --system+ ", " --profile+
Wie eben, nur dass sich der Test so verhält, als wenn  B<LOCAL_PORTAGE_CONFIG=true> gesetzt wäre.
.TP
.BR --stable- ", " --testing- ", " --non-masked- ", " --system- ", " --profile-
Wie eben, nur dass sich der Test so verhält, als wenn  B<LOCAL_PORTAGE_CONFIG=false> gesetzt wäre.
.TP
.BR --installed-unstable ", " --installed-testing ", " --installed-masked
Findet nur Pakete, die zumindest eine nicht-stabile, testing, oder maskierte
Version installiert haben (der Test verhält sich, als wenn
B<LOCAL_PORTAGE_CONFIG=false> gesetzt wäre).
Falls mehrere dieser Optionen in einem Test kombiniert werden, muss die
selbe Version alle Kriterien erfüllen.
.TP
.BR --world
Findet nur Pakete aus @world.
Dies ist analog zu "emerge @world", d.h. es enthält nicht nur die Pakete aus
der world-Datei sondern auch aus world_set und das @system Set.
Falls dies nicht alles enthalten sein soll, gibt es alternative Optionen.
.TP
.BR --world-file
Findet nur Pakete aus der world-Datei oder aus dem @system Set.
.TP
.BR --world-set
Findet nur Pakete aus world_set oder den @system Set.
This only matches packages from world_set or from the @system set.
.TP
.BR --selected
Findet nur @selected Pakete.
Dies ist analog zu "emerge @selected", d.h. es enthält nicht nur Pakete im
world-Datei sondern auch in world_sets (falls @system in world_set enthalten
ist, ist das Verhalten natürlich identisch zu B<--world>).
Falls dies nicht alles enthalten sein soll, gibt es alternative Optionen.
.TP
.BR --selected-file
Findet nur Pakete aus der world-Datei.
.TP
.BR --selected-set
Findet nur Pakete aus world_set.
.TP
.BR --binary
Findet nur Pakete mit einer Binärdatei (*.tbz2, *.gpkg.tar oder *.xpak) in PKGDIR.
Die Version des Binärfiles muss mit mindestens einer vorhandenen oder einer installierten Version übereinstimmen.
(Falls keine Version vorhanden ist, kann das Paket ebenfalls nicht gefunden werden).
Nur die reine Existenz einer entsprechenden Datei mit *.tbz2, *.gpkg.tar oder *.xpak wird überprüft:
Ob Portage die Datei tatsächlich benutzen kann, hängt auch von Meta-Daten innerhalb dieser Datei ab (wie etwa USE settings), was von eix nicht beachtet wird.
.TP
.BI --multi-binary NR
Findet nur Pakete mit einer Version, die mindest I<NR> Dateien hat, die auf B<--binary> zutreffen.
.TP
.B --nonvirtual
Findet nur Pakete mit mindestens einer Version aus dem Hauptbaum oder einem nicht-virtuellen Overlay.
.TP
.B --virtual
Findet nur Pakete mit mindestens einem nicht-virtuellen Overlay.
.TP
.BR -O ", " --overlay
Findet nur Pakete mit mindestens einer Version in einem Overlay.
.TP
.BI "--in-overlay " overlay
Findet nur Pakete mit mindestens einer Version in einem Overlay, der auf B<overlay> passt.

Falls diese Option wiederholt wird, werden die zusätzlichen I<overlay>-Argumente
zu einer Liste zulässiger Overlays zusammengefasst.

I<overlay> kann entweder ein Wildcard-Muster oder eine Zahl sein.
Beachten Sie, dass sie mit der Standardeinstellung B<OVERLAYS_LIST=all-used-renumbered>
nicht die korrekten Overlaynummern sehen; für eine Liste der korrekten Overlaynummern
können Sie beispielsweise den Aufruf

B<OVERLAYS_LIST=all eix --not>

oder in Skripten besser

B<OVERLAYS_LIST=all PRINT_COUNT_ALWAYS=never eix -!>

benutzen.
Die speziellen Werte B<0> oder B<$PORTDIR> passen auf den Hauptbaum (der
in diesem Zusammenhang als der 0-te Overlay betrachtet wird).

Falls I<overlay> leer ist (or weggelassen wird, falls B<--in-overlay>
die letzte Option war) dann passen alle Overlays außer dem Hauptbaum
(d.h. B<--in-overlay ''> ist das selbe wie B<-O>).
.TP
.BI "--only-in-overlay " overlay
Findet nur Pakete, die nur Versionen haben, die in einem Overlay liegen,
der auf I<overlay> passt.

Falls diese Option wiederholt wird, werden die zusätzlichen I<overlay>-Argumente
zu einer Liste zulässiger Overlays zusammengefasst.

I<overlay> kann entweder ein Wildcard-Muster oder eine Zahl sein, analog wie in B<--in-overlay>.
Insbesondere findet B<--only-in-overlay ''> alle Pakete, die nicht im Hauptbaum
sondern nur in Overlays liegen.
.TP
.BR -J ", " --installed-overlay
Findet nur Pakete, die aus einem Overlay installiert wurden.
Für vollkommen zuverlässige Ergebnisse sollte B<CHECK_INSTALLED_OVERLAYS=true>
gesetzt werden (was nicht die Standardeinstellung ist, weil es Tests massiv verlangsamt).
Siehe B<CHECK_INSTALLED_OVERLAYS> für Details.
.TP
.BI "--installed-from-overlay " overlay
Dies ist analog zu B<--in-overlay> mit dem Unterschied, dass nur
Pakete gefunden werden, die zumindest eine Version aus I<overlay> installiert haben.
Beispielsweise wird B<--installed-from-overlay 0> nur die Pakete finden,
bei denen zumindest eine Version aus dem regulären Portagebaum installiert ist.
Wie für -J sollte B<CHECK_INSTALLED_OVERLAYS=true> gesetzt werden, um
vollständig zuverlässige Ergbnisse zu erhalten.
.TP
.B --installed-in-some-overlay
Findet nur Pakete, die zumindest eine Version installiert haben, die
auch in einem Overlay zu finden ist.
.TP
.BI "--installed-in-overlay " overlay
Dies ist analog zu B<--in-overlay> mit dem Unterschied, dass nur Pakete gefunden
werden, die zumindest eine installierte Version in I<overlay> haben.
Beispielsweise wird B<--installed-in-overlay 0> nur Pakete finden, die mindestens
eine Version installiert haben, die es im regulären Portagebaum gibt.
.TP
.B --restrict-fetch
Findet nur Pakete, die zumindest eine Version mit RESTRICT=fetch haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-mirror
Findet nur Pakete, die zumindest eine Version mit RESTRICT=mirror haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-primaryuri
Findet nur Pakete, die zumindest eine Version mit RESTRICT=primaryuri haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-binchecks
Findet nur Pakete, die zumindest eine Version mit RESTRICT=binchecks haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-strip
Findet nur Pakete, die zumindest eine Version mit RESTRICT=strip haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-test
Findet nur Pakete, die zumindest eine Version mit RESTRICT=test haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-userpriv
Findet nur Pakete, die zumindest eine Version mit RESTRICT=userpriv haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-installsources
Findet nur Pakete, die zumindest eine Version mit RESTRICT=installsources haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-bindist
Findet nur Pakete, die zumindest eine Version mit RESTRICT=bindist haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-parallel
Findet nur Pakete, die zumindest eine Version mit RESTRICT=parallel haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --properties-interactive
Findet nur Pakete, die zumindest eine Version mit PROPERTIES=interactive haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --properties-live
Findet nur Pakete, die zumindest eine Version mit PROPERTIES=live haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --properties-virtual
Findet nur Pakete, die zumindest eine Version mit PROPERTIES=virtual haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --properties-set
Findet nur Pakete, die zumindest eine Version mit PROPERTIES=set haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.BR -T ", " --test-obsolete
Findet nur obsolete Pakete.

Pakete sind obsolete, wenn sie redundante Einträge in /etc/portage/package.*
haben (falls B<TEST_FOR_REDUNDANCY> gesetzt ist), oder falls nicht alle
installierten Versionen existieren (falls B<TEST_FOR_NONEXISTENT> gesetzt ist).

Was als redundant gilt, wird durch die unten beschriebenen <REDUNDANT_IF>-Variablen festgelegt,
und was als nicht-existent betrachtet wird, wird durch die B<NONEXISTENT_IF>-Variablen festgelegt.
Der Test für Versionen von obsoleten Overlays funktioniert nur dann zuverlässig,
wenn B<CHECK_INSTALLED_OVERLAYS=true> gesetzt ist (was nicht die Standardeinstellung ist,
weil es Tests dramatisch verlangsamt).
Siehe B<CHECK_INSTALLED_OVERLAYS> für Details.

Beachte, dass diese Option nur Pakete in der Datenbank test.
Insbesondere werden keine Einträge für beispielsweise umbenannte oder aus dem Portagebaum gelöschte Pakete
mit dieser Option gefunden werden.
Letzteres wird mit der Option B<-t> bedient.

Daher wird diese Option am Besten mit -t kombiniert, wenn auch andere Arten obsoleter Einträge gefunden werden sollen.

Falls es einen Grund gibt, bestimmte Pakete von diesem Test auszuschließen,
so können diese Einträge in die Datei (oder Verzeichnis) /etc/portage/package.nowarn geschrieben werden.
Diese Datei (und wie alternative/zusätzliche Dateien angegeben werden können) wird später beschrieben.
.TP
.BR -| ", " --pipe
(Beachten Sie, dass die Shell normalerweise kein B<|>-Zeichen übergibt, wenn es
nicht gequotet ist).

Findet nur Pakete/Masken aus Standard-Input; normalerweise wird dies in einer Pipe benutzt,
etwa als Ausgabe von emerge -pv (oder genlop -p).
Tatsächlich werden im Input alle Worte (durch Leerzeichen oder Zeilenende separiert) beachtet,
die das Zeichen / enthalten.

Jedes solche Wort wird als Maske betrachtet (in der Form des ersten Eintrags der /etc/portage/package.*-Dateien),
aber eine Heuristik erlaubt, dass Versionen auch ohne ein explizites führendes B<=>-Zeichen angegeben werden können.
(Dies kann zu Mehrdeutigkeiten führen; benutzen Sie B<--pipe-mask>, wenn Sie ein zuverlässiges Ergebnis benötigen).

Alle verfügbaren Pakete/Versionen, die auf eine Maske der Standardeingabe passen, werden in der Ausgabe als markiert behandelt.
Details zu Letzterem stehen in der Beschreibung der B<marked> und B<markedversions:*> Formatstrings.

Auch wenn B<--pipe> mehr als einmal auftaucht, wird die Standard-Eingabe natürlich nur einmalig gelesen,
aber wiederholt für jedes Auftauchen interpretiert (d.h. falls der erste --pipe Ausdruck passt,
werden auch alle anderen passen).

Falls der Standard-Input nur zum Markieren aber nicht zur Auswahl benutzt werden soll,
kann etwa folgender Ausdruck benutzt werden:

B<eix irgendwas -a "-(" --pipe -o "-)">

Falls die Option B<--pipe-name> oder B<--pipe-version> später in der Argumentliste vorkommt,
verhält sich B<-pipe> wie B<--pipe-name> bzw. B<--pipe-version>.
.TP
.B --pipe-name
Dies ist analog zu B<--pipe> mit dem Unterschied, dass nur Masken in der Eingabe erlaubt sind,
d.h. bei der Angabe von Paketversionen ist ein führendes B<=>-Zeichen nicht optional.
Dies verhindert Mehrdeutigkeiten, wenn ein Teil des Namens wie eine Versionsnummer aussieht.
Benutzen Sie diese Option anstelle von B<--pipe> für ein zuverlässiges Ergebnis!
.\" }}}

.\" {{{ -------- Operandenwahl
.SS Operandenwahl
Die nachfolgenden Optionen legen die Felder fest, auf die SUCHMUSTER passen soll.
Mehrere Felder können in einem Ausdruck festgelegt werden (der Ausdruck passt,
falls das Suchmuster auf mindestens eines der spezifierten Felder passt).
Falls keine diese Optionen angegeben wird, wird die Vorgabeeinstellung anhand einer
Heuristik gewählt, die von der Form von SUCHMUSTER abhängt.
In den meisten Fällen wird das Vorgabefeld B<--name> sein, aber wenn das
SUCHMUSTER "speziell" aussieht, etwa "cat/n" oder "@set", so wird das Vorgabefeld
auf B<--category-name>, B<--set>, B<--description>, B<--homepage> oder B<--license> geändert.
Details der Heuristik werden in der später erklärten B<DEFAULT_MATCH_FIELD>-Konfigurationsvariable festgelegt.
Je nach Wert dieser Variablen kann es auch passieren, dass eine der folgenden
Optionen explizit für jede Suche angegeben werden muss.
.TP
.BR -y ", " --any
Jedes Feld wird durchsucht.
Dies ist gleichbedeutend damit, gleichzeitig alle Optionen B<--name>, B<--description>, B<--category>, ... anzugeben.
Man wird dies immer dann wählen, wenn man sicher sein möchte, keine Treffer zu übersehen.
Man sollte allerdings damit rechnen, dass die Trefferliste viel länger als erwartet sein wird.
(Wer neugierig ist, kann mit den Optionen B<-vl> and Weiterleitung nach grep
den oft unerwarteten Grund herausfinden, weshalb ein Treffer bei B<-y> auftaucht).
Um zumindest den Abhängigkeitsstring von der Suche auszunehmen, empfiehlt sich manchmal
die Kombination mit B<DEP=false>, z.B.

B<DEP=false eix --any SIP>

.TP
.BR -s ", " --name
z.B. "eix"
.TP
.BR -S ", " --description
z.B. "Small utility for searching .."
.TP
.BR -C ", " --category
z.B. "app-portage"
.TP
.BR -A ", " --category-name
z.B. "app-portage/eix"
.TP
.BR -H ", " --homepage
z.B. "@PACKAGE_URL@"
.TP
.BR -L ", " --license
z.B. "GPL-2"
.TP
.BR --available-deps ", " --available-depend ", " --available-rdepend ", " --available-pdepend ", " --available-bdepend ", " --available-idepend
Dieser Test kann nur dann etwas finden, wenn B<DEP=true> benutzt wird
(und B<DEP=true> bei der Erzeugung des Cachedatei benutzt wurde).
Er tested gegen B<DEPEND>, B<RDEPEND>, B<PDEPEND>, B<BDEPEND> bzw. B<IDEPEND>
(oder mit B<--deps> gegen irgendeines davon) für irgendeine verfügbare Version des Pakets.
B<--deps> ist das gleiche wie B<--depend> B<--rdepend> B<--pdepend> B<--bdepend> B<--idepend>.
Beachten Sie, dass gegen den String ohne irgendwelche Interpretatino oder
Modifikation getestet wird; nur Wort-Trenner werden einzelne Leerzeichen.
Insbesondere kann der String, gegen den getestet wird, so aussehen:

app-admin/fam nls? ( sys-devel/gettext ) =dev-libs/apr-1* !!dev-db/libpq

Daher ist der Test tatsächlich nicht nur gegen abhängige Pakete, sondern
auch gegen Blocker und/oder Konditionale und gegen verschiedene Möglichkeiten,
Versionen zu spezifizieren.
.TP
.BR --installed-deps ", " --installed-depend ", " --installed-rdepend ", " --installed-pdepend ", " --installed-bdepend ", " --installed-idepend
Diese Optionen sind ähnlich zur entsprechenden --available-* Option, aber mit dem Unterschied,
dass der entsprechende Abhängigkeitsstring aus den installierten Versionen des Pakets genommen wird.
Im Gegensatz zu --available-* wird dieser Test nicht von B<DEP> beeinflusst.
Diese Option wird üblicherweise mit B<--deps-installed> kombiniert um sicherzustellen,
dass tatsächlich der Inhalt der installierten Version gelesen wird.

Man beachte, dass Abhängigkeiten installierter Versionen i.d.R. viel einfacher sind und z.B. keine Konditionale enthalten.
.TP
.BR --deps ", " --depend ", " --rdepend ", " --pdepend ", " --bdepend ", " --idepend
Dies sind Abkürzungen für die gleichzeitige Angabe der entsprechenden --available-* und --installed-* Optionen.
.TP
.BR --set
Name eine lokalen Paket-Sets oder Version in der Datenbank
(d.h. entsprechend einer Datei aus B</etc/portage/sets>, B</etc/portage/sets.eix>,
oder eines anderen Verzeichnisses ausB<EIX_LOCAL_SETS_ADD>; siehe die Kommentare zu B<EIX_LOCAL_SETS>).
Die "profile", "system" und "world" sets sind hier bewusst ausgenommen, da diese mit
B<--profile[+-]>, B<--system[+-]>, B<--world>, B<--world-all> oder B<--world-sets> getestet werden sollten.
.TP
.B --src-uri
SRC_URI einer Version in der Datenbank.
.TP
.B --eapi
EAPI einer Version in der Datenbank, z.B. "6"
.TP
.B --installed-eapi
EAPI einer installierten Version
.TP
.B --slot
Slotname einer Version in der Datenbank, z.B. "kde-4"
.TP
.B --fullslot
Slotname einer Version in der Datenbank ggf. mit Subslot, z.B. "3/1.4"
.TP
.B --installed-slot
Slotname einer installierten Version.
Beachten Sie, dass ohne die Option B<--care> (oder B<CAREMODE=true>) der Slotname ev. nur vermutet wird.
.TP
.B --installed-fullslot
Slotname einer installierten Version ggf. mit Subslot.
Beachten Sie, dass ohne die Option B<--care> (oder B<CAREMODE=true>) der Slotname ev. nur vermutet wird.
.TP
.BR -U ", " --use
Ein Useflag, das im IUSE mindestens eines Ebuilds von einer Version des Pakets festgelegt wird.
Normalerweise wird diese Option mit -e kombiniert.
.TP
.B --installed-with-use
Ein Useflag, das während der Installation eines Pakets aktiv ist.
Natürlich kann dieser Test nur dann erfolgreich sein, wenn das Paket installiert ist.
Es gelten die selben Einschränkungen wir für B<-I>, d.h. nur diejenigen Pakete werden gefunden,
die es noch in der Datenbank gibt.
.TP
.B --installed-without-use
Ein Useflag, das während der Installation eines Pakets inaktiv ist.
Natürlich kann dieser Test nur dann erfolgreich sein, wenn das Paket installiert ist.
Es gelten die selben Einschränkungen wir für B<-I>, d.h. nur diejenigen Pakete werden gefunden,
die es noch in der Datenbank gibt.
.\" }}}

.\" {{{ -------- Match-Algorithmus
.SS "Match-Algorithmus"
Die folgenden Optionen legen den Algorithmus fest, nach dem das Operandenfeld
gegen das SUCHMUSTER getestet werden soll.
Nur ein Algorithmus kann pro AUSDRUCK gewählt werden.
Falls keine dieser Optionen benutzt wird, wird die Vorgabe anhand einer
Heuristik ausgewählt, die von der Gestelt des Suchmusters und vom ausgewählten
Operandenfeld abhängt.
In den meisten Fällen wird diese Vorgabe B<--regex> sein (oder B<--regex-case>,
falls der Ausdruck Großbuchstaben enthält), außer wenn das Suchmuster aussieht
wie "typischerweise" ein glob-Muster or ein Teilstring (in diesem Fall wird der
entsprechende Algorithmus die Vorgabe), oder falls das ausgewählte
Operandenfeld sich nur auf USE-flags, sets, EAPI oder SLOT bezieht, so dass
die meisten Benutzer vermutlich erwarten, dass auch tatsächlich gegen den
gesamten String getestet werden soll.
Details der Heuristik werden in der später erklärten B<DEFAULT_MATCH_ALGORITHM>-Konfigurationsvariable festgelegt.
Je nach Wert dieser Variablen kann es auch passieren, dass eine der folgenden
Optionen explizit für jede Suche angegeben werden muss.
.TP
.BR -e ", " --exact
Das Suchmuster ist ein exakter (ganzer) String.
Beispielsweise zeigt "eix -e gcc" nur Pakete des namens "gcc".
.TP
.BR -b ", " --begin
Das Suchmuster ist ein Stringanfang.
Beispielsweise zeigt "eix -b gcc" die Pakete mit dem Namen "gcc", aber
beispielsweise auch "gcc-config".
.TP
.BR --end
Das Suchmuster ist ein Stringende.
.TP
.BR -z ", " --substring
Das Suchmuster taucht irgendwo im String auf.
.TP
.BR -f " [" I<N> "], " --fuzzy " [" I<N> "]"
Fuzzy-Suche mit dem maximalen Levenshtein-Abstand I<N> (default @LEVENSHTEIN_DISTANCE_DEFAULT@) für den ganzen String.
Diese Option reduziert die Suchgeschwindigkeit.
.TP
.BR -p ", " --pattern
Das Suchmuster ist ein Wildcard-pattern (gegen desn gesamten String. Siehe
.BR fnmatch (3)
und/oder
.BR glob (7)
für weitere Details.
Vorsicht bei der Übergabe des Suchmusters in einer Shell (Quoting!).
.TP
.BR -r ", " --regex
Das Suchmuster ist ein regulärer Ausdruck (ohne Beachtung der Großschreibung).
Nur ein Teilstring muss passen (außer wenn \(ha oder $ benutzt werden).
Das leere Suchmuster passt auf alles.
Weitere Informationen finden sich in
.BR regex (7).
Vorsicht bei der Übergabe des Suchmusters in einer Shell (Quoting!).
.TP
.BR --regex-case
Wie B<--regex>, aber mit Beachtung der Groß-/Kleinschreibung.
.\" }}}
.\" {{{ -------- Layouts festlegen
.SS Layouts festlegen \fP(siehe B<FORMATSTRING> weiter unten)
.TP
.BR --format " " I<FORMATSTRING>
Definiert den I<FORMATSTRING>.
Seit eix-0.29.6 überschreibt diese Option alle anderen Möglichkeiten
zur Wahl des Formatstrings wie etwa das Setzen von B<DEFAULT_FORMAT> oder B<FORMAT>.
Wird diese Option hingegen nicht benutzt, sondern statt dessen eine der Variablen
B<FORMAT>, B<FORMAT_VERBOSE>, oder B<FORMAT_COMPACT> gesetzt, so hängt die
Wahl des Formats vom wert von B<DEFAULT_FORMAT> ab und kann zusätzlich noch
durch die Optionen B<--verbose>, B<--compact> bzw. B<--normal> beeinflusst werden.
.\" }}}
.\" }}}
.\" {{{ -------- Options for eix-update
.SS Spezielle Optionen für B<eix-update>
.TP
.BR -H ", " --nostatus
Kein Update der Statuszeile.
.TP
.BR --force-status
Update der Statuszeile, selbst wenn die Ausgabe kein Terminal ist
oder falls TERM nicht mit einem Wort aus TERM_STATUSLINE beginnt.
.TP
.BR  -o " " I<Ausgabedatei> ", " --output " " I<Ausgabedatei>
Mit dieser Option schreibt B<eix-update> die eix-Datenbank nach I<Ausgabedatei>
statt B<@EIX_CACHEFILE@>.
Mit dieser Option wird die gesetzte B<umask> berücksichtigt.
Andernfalls wird die B<umask> zwangsläufig auf B<002> zur Erzeugung der Datei gesetzt.
.TP
.BR  -a " " I<Overlay> ", " --add-overlay " " I<Overlay>
Dies ist ähnlich wie I<Overlay> to B<PORTDIR_OVERLAY> zu /etc/portage/make.conf
oder zu B<ADD_OVERLAY> hinzuzufügen, hat aber den Vorteil,
dass Letztere nicht modifiziert werden müssen, und dass es problemlos
möglich ist, Leerzeichen in I<Overlay> zu benutzen.
Overlays mit dieser Option kommen nach Overlays aus B<KEEP_VIRTUALS>.
Falls I<Overlay> bereits in der Liste der Overlays enthalten ist, so hat diese
Option keine Auswirkingen.
Es ist ausdrücklich zulässig, diese Option wiederholt zu benutzen,
um mehrere Overlays hinzuzufügen.

.TP
.BR -x " " I<Overlay> ", " --exclude-overlay " " I<Overlay>
Dies ist ähnlich wie I<Overlay> to B<EXCLUSE_OVERLAY> hinzuzufügen,
hat aber den Vorteil, dass Letzteres nicht modifiziert werden muss,
und dass es problemlos möglich ist, Leerzeichen in I<Overlay> zu benutzen.
I<Overlay> wird als Maske aufgefasst.
Alle passenden Overlays (auch diejenigen, die später mit B<--add-overlay>
hinzugefügt wurden), werden aus der Liste der Overlays ausgeschlossen.
Das B<PORTDIR>-Verzeichnis wird als ein weitere Overlay betrachtet,
der ausgeschlossen werden kann (in diesem Fall wird der erste I<Overlay>
der Liste als B<PORTDIR> gespeichert).
Es ist ausdrücklich zulässig, diese Option wiederholt zu benutzen,
um mehrere Overlays auszuschließen.
.TP
.BR -m " " I<Overlay> " " I<Methode> ", " --override-method " " I<Overlay> " " I<Methode>
Ändert die Cachemethode von I<Overlay>
(der B<PORTDIR>-Verzeichnis ist ein erlaubter I<Overlay>) auf I<Methode>.
I<Overlay> wird als Maske betrachtet, d.h. es darf Wildcards enthalten.
Falls I<Overlay> auf nichts in der Liste der Overlays passt, hat diese Option keine Auswirkungen.
Diese Option ist ähnlich wie das Hinzufügen des Eintrags "I<Overlay> I<Methode>"
am Ende der B<OVERRIDE_CACHE_METHOD>-Variablen.
Es ist ausdrücklich zulässig, die Option wiederholt zu benutzen, um
Cachemethoden für verschiedene Overlays zu überschrieben.
Die zuletzt passende Überschreibung gewinnt.
Insbesondere kann man mit dieser Option den Inhalt von B<OVERRIDE_CACHE_METHOD> überschreiben.
.TP
.BR -r " " I<Overlaypfad> " " I<Overlaylabel> ", " --repo-name " " I<Overlaypfad> " " I<Overlaylabel>
Der Overlay I<Overlay-path> erhält das Lebel I<Overlaylabel>, unabhängig von anderen Settings.
Dies kann mit B<REPO_NAMES> überschrieben werden.
Im Gegensatz zu B<REPO_NAMES> ist I<Overlaypfad> kein Muster sondern ein genauer Pfad.
.TP
.BR -v " " --verbose
Gibt die effektiv benutzte Cachemethode für jedes Ebuild aus.
Dies erzeugt eine Menge an Ausgaben und ist hauptsächlich zum Debuggen nützlich,
etwa wenn unklar ist, weshalb eix-update schneller/langsamer ist als erwartet.
.\" }}}

.\" {{{ AUSGABE
.SH AUSGABE
.SS Slots
Anders als in der üblichen Ausgabe von Versionen in emerge kann <eix>
auch Slotnamen ausgeben, wenn sie nichttrivial (leer oder "0") sind.
Ob dies geschieht, wird u.a. durch B<FORMATSTRING> festgelegt.

Falls Slots ausgegeben werden, wird der Slotname entweder mit einem
Doppelpunkt von der Versionsnummer abgetrennt, oder der Slotname wird
in Klammern geschrieben.
Der bevorzugte Modus wird in der Variable B<COLON_SLOTS> festgelegt.

Falls B<PROPERTIES> oder B<RESTRICT> im Ebuild gesetzt sind, wird dies
bei Standardeinstellung im Versionsstring angezeigt; Details können durch Setzen
von Konfigurationsvariablen beeinflusst werden.

Einige Beispiele:
.TP
.BR 4.1.1:4.1 "   oder   " 4.1.1(4.1)
Dies ist Version 4.1.1, die in den Slot "4.1" installiert wird.
.TP
.BR 3.14p:GNAT-3.14p "   oder   " 3.14p(GNAT-3.14p)
Dies ist Version 3.14p, die in den Slot "GNAT-3.14p" installiert wird.
.TP
.B 2.0.0_rc1-r6
Dies ist Version 2.0.0_rc1-r6, und der SLOT ist leer oder "0".
.TP
.B 1.0*ilvs\(hafmpbstuidP{tbz2,gpkg:3,pak:2}
Dies ist Version 1.0, und gesetzt sind
PROPERTIES="interactive live virtual set" sowie
RESTRICT="fetch mirror primaryuri binchecks strip test userpriv installsources bindist parallel".
Darüberhinaus existiert eine *.tbz2, drei *.gpkg.tar und zwei *.xpak-Dateien
(Binärpakete ohne bzw. mit FEATURES=binpkg-multi-instance bzw, FEATURES=gpkg)
für diese Version in B<PKGDIR>.
.TP
.B 5.0-r3(5.0R3)\(haf "   oder   " 5.0-r3:5.0R3\(haf
Dies ist Version 5.0-r3, die in Slot 5.0R3 installiert wird, und die RESTRICT=fetch hat.

.SS Maskierung
Wer Gentoo für mehr als eine Woche benutzt hat, wird vermutlich sofort
das Format für die Maskierung von Versionen verstehen.
Nichtsdestotrotz wird es hier anhand einiger Beispiele erklärt.
Es wird natürlich nur die Ausgabe bei Standardeinstellungen beschrieben; Details können
durch Konfigurationsvariablen beeinflusst werden.
.TP
.B [P]2.95.3-r8
Eine Maske für das Paket wurde in der packages-Datei des Profiles gefunden,
aber diese Version passt nicht.
Portage nennt dies "masked by profile".
.TP
.B [M]4.0.0_alpha20050213
Die Version passt auf einen Eintrag aus /etc/portage/package.mask, $PORTDIR/profiles/package.mask
oder einer package.mask des Profiles.
Portage nennt dies "masked by package.mask".
.TP
.B [m]4.1.4
Die Version passt zu einer lokalen Maske (von /etc/portage/package.mask), aber sie ist
weder "masked by profile" noch in $PORTDIR/profiles/package.mask maskiert.
.TP
.B {P}2.95.3-r8
Die Version war ursprünglich "masked by profile", aber dies wurde lokal durch /etc/portage/profile/packages geändert.
.TP
.B {M}4.0.0_alpha20050213
Die Version war ursprünglich in $PORTDIR/profiles/package.mask, aber dies wurde lokal durch /etc/portage/package.unmask geändert.
.TP
.B *3.3.3
Die Version ist "masked by missing keyword", aber stabil für eine fremde Architektur.
.TP
.B ~*3.3.3
Die Version ist "masked by missing keyword", auf keiner Architektur stabil, aber auf einer fremden Architektur instabil.
.TP
.B **3.3.3
Die Version ist "masked by missing keyword" für alle Architekturen.
.TP
.B (**)3.4.3-r2
Die Version hatte ursprünglich kein Keyword, aber dies wurde lokal geändert (in /etc/portage/package.{accept_,}keywords oder durch ACCEPT_KEYWORDS).
.TP
.B -0.8.14
Maskiert durch -ARCH.
.TP
.B ~3.3.5.20050130
Die Version ist "masked by ~keyword".
.TP
.B (~)3.3.5.20050130
Die Verstion war ursprünglich "masked by ~keyword", aber dies wurde lokal geändert (in /etc/portage/package.{accept_,}keywords oder durch ACCEPT_KEYWORDS).
.TP
.B [M]~1.0.9626
Diese Version ist sowohl "masked by package.mask" als auch "masked by ~keyword".
.TP
.B [m](~)4.1.4-r1
Die Version was ursprünglich nur "masked by ~keyword", aber dies wurde lokale geändert (in /etc/portage/package.{accept_,}keywords oder durch ACCEPT_KEYWORDS).
Darüberhinaus wurde die Version lokal maskiert (in /etc/portage/package.mask).
.TP
.B 3.3.1
Dies schließlich ist eine stabile Version (die auch ohne lokale Settings stabil wäre).
.SS eix-diff
Die Ausgabe von B<eix-diff> wird vollständig durch Konfigurations-Variablen kontrolliert
(B<DIFF_FORMAT_NEW>, B<DIFF_FORMAT_DELETE>, B<DIFF_FORMAT_CHANGED> und eine Menge
Variablen die - zumindest in der Standardeinstellung - durch diese über verzögerte Ersetzung benutzt werden, s. unten).
Die folgende Erklärung anhand von Beispielen kann daher nur das Verhalten
der Standardeinstellung der aktuellen eix-Versin beschreiben.
Obwohl dieses Standardeinstellung lange Zeit unverändert blieb, wird keine
Stabilität der Standardeinstellungen für zukünftige eix-Versionen garantiert.
.TP
.B "[N]   >> foo/bar (~1.0): description of foo/bar"
Das Paket B<foo/bar> ist neu im Baum.
.TP
.B "[*N]  >> foo/bar (1.0): description of foo/bar"
Das Paket B<foo/bar> ist neu im Baum.
Darüberhinaus hat as eine Version (1.0), die ohne Demaskieren/Keywording installiert werden könnte.
.TP
.B "      << foo/bar ({M}1.0): description of foo/bar"
B<foo/bar> wurde aus dem Baum entfernt; die vorherhige Version B<1.0> war maskiert, aber sie ist derzeit nicht mehr maskiert.
(wahrscheinlich, weil der Entwickler den entsprechenden Eintrag der package.mask-Datei zusammen mit der Löschung des Pakets entfernt hatte).
.TP
.B "[*>]   == foo/bar (1.0): description of foo/bar"
Der Status des Pakets B<foo/bar> im Baum hat sich geändert (für die lokalen Settings):
es hat eine Version (1.0) erhalten, die ohne lokales Demaskieren/Keywording installiert werden könnte,
währen der im vorherigen Baum foo/bar keine solche Version existierte. Darüberhinaus bedeutet das
.B >
dass ein Slot eine höhere Version erhielt. In diesem Fall ist tatsächlich die selbe Änderung für die beiden Symbole
.B >
und B<*> verantwortlich.
.TP
.B "[><]  == foo/bar (1.1(1) 2.0(2) -> 1.0(1) 2.1(2)): description"
Der Status des Pakets B<foo/bar> im Baum hat sich geändert (für die lokalen Settings):
Die Symbole an der linken Seite bedeuten, dass ein Slot eine höhere Version erhielt (die ohne Äderung von Maske/Keywords installiert werden könnte),
ein anderer Slot verlor eine solche "beste" Version.
Durch Betrachten der Versionsstrings wird klar, dass Slot B<2> eine neue Version erhielt
(die vorherige stabile dieses Slots war B<2.0>m die neue ist B<2.1>),
und das die vorherige höchste stabile Version B<1.1> des Slots B<1> entfernt oder maskiert wurde
(die aktuell stabile Version dieses Slots ist jetzt B<1.0>).
.TP
.B "[U?]  == foo/bar (1.1(1)@01.01.2009; 1.1(1) -> 2.0(2)): description"
Der Status des Pakets B<foo/bar> im Baum hat sich geändert (für die lokalen Settings):
Die Symbole an der linken Seite bedeuten, dass für einen installierten Slot ein Upgrade möglich ist (ohne Veränderung von Maske/Keywords),
und das ein anderer installierter Slot entfernt/maskiert wurde.
Durch Betrachten der Versionsstrings wird klar, dass die installierte Version B<1.1> des Slots B<1>
entfernt oder maskiert wurde, und dass es keine andere installierte Version des Slots B<1> gibt.
Eine stabile Version B<2.0> erschien neu im Slot B<2> (d.h. Slot B<2> existiere vorher nicht oder hatte keine stabile Version).

Da keine Version des Slots B<2> installiert war, kann eix in dieser Situation
nicht entscheiden, ob das Symbol "B<U>" wirklich angemessen ist:
Da eix keine Abhängigkeiten berücksichtigt, weiß es nicht, ob der neue Slot
beispielsweise von der world-Datei benutzt würde, oder ob es nur eine
Abhängigkeit für den alten Slot gibt.
Daher wird das Symbol "B<U>" in dieser Situation nur angezeigt, falls
B<UPGRADE_TO_HIGHEST_SLOT=true> or falls das Paket in
B</etc/portage/package.slot_upgrade_allow> gelistet ist.

Tatsächlich wäre der output
.B "[U?><] == foo/bar ..."
konsistenter, weil zusätzlich ein Slot eine höhere stabile Version erhielt
und die höchste stabile Version eines anderen Slots entfernt wurde.
Aber weil dies tyopischerweise von "B<U>" bzw. "B<?>" impliziert ist,
war es bei den Standardeinstellungen eine Design-Entscheidung, dass bei der
Ausgabe von B<U> oder B<?> die Ausgabe der Symbole
.B <
bzw.
.B >
unterdrückt wird.
Natürlich ist es möglich, einen anderen B<DIFF_FORMAT_HEADER_CHANGED>-String
zu definieren, der einer anderen Politik folgt.
.\" }}}

.\" {{{ FORMATSTRING
.SH FORMATSTRING
.LP
Ein Formatstring kann konditionelle Blocks, Paketeigenschaften, Farben,
und normale Strings enthalten. Normale Strings werden wie erwartet ausgegeben
(wobei spezielle Escape-Sequenzen berücksichtigt werden, s. unten);
für die Berechnung von Größen wie z.B. Tabs wird UTF8-Kodierung unterstellt.
.\" {{{ -------- konditionelle Blocks
.SS konditionelle Blocks
Bedingungen sind sehr einfach: Eine Eigenschaft wird expandiert, und der
erhaltene String wird gegen einen anderen String getestet.
Wenn sie übereinstimmen, ist die Bedingung wahr, und der Block wird ausgeführt.
Bedingungen können negiert werden, so dass der else-Teil ausgeführt wird,
falls die Bedingung wahr ist, und der if-Teil, falls die Bedingung falsch ist.
Der else-Teil kann auch weggelassen werden.
.TP
.BR { [ ! ] I<EIGENSCHAFT> [ = I<RHS>] } I<TCODE> {}
Führt I<TCODE> aus, falls der String aus der Expansion von I<EIGENSCHAFT> gleich I<RHS> ist.
Das B<!> würde das Verhalten negieren.
.TP
.BR { [ ! ] I<EIGENSCHAFT> [ = I<RHS>] } I<TCODE> {else} I<FCODE> {}
Führt I<TCODE> aus, falls der string aus der Expansion von I<EIGENSCHAFT> gleich I<RHS> ist.
Andernfalls wird I<FCODE> ausgeführt.

I<RHS> ist entweder eine Eigenschaft (falls in <> eingeschlossen), eine variable
(falls ein $ vorgestellt ist), oder ein String (in allen anderen Fällen, oder falls in Anführungszeichen).

I<EIGENSCHAFT> kann entweder eine der unten spezifierten Paketeigenschaften sein
oder ein Variablenzugriff.
Ein Variablenzugriff hat die Gestalt B<$>I<VARIABLE>.
I<VARIABLE> muss nicht initialisiert werden; der Vorgabewert ist der Leerstring.

Um I<VARIABLE> zur Laufzeit zu ändern, dient diese Syntax:
.TP
.BR { [ ! ] *I<VARIABLE> [ = I<RHS>] }
Dies sehr die Laufzeit-Variable B<VARIABLE> auf I<RHS>.
Mit B<!> ist das Ergebnis 1 oder leer, je nachdem ob I<RHS> leer ist.
Falls der zweite Teil (einschließlich des B<=>-Zeichens) weggelassen wird, gibt es eine spezielle Bedeutung:
B<{*>I<VARIABLE>B<}> setzt die I<VARIABLE> auf 1, B<{!*>I<VARIABLE>B<}> setzt die I<VARIABLE> auf den Leerstring.
.\" }}}

.\" {{{ -------- Paketeigenschaften
.SS Paketeigenschaften
Namen, die sich auf spezielle Eigenschaften des Pakets beziehen, das gerade ausgegeben wird.
Falls der Name benutzt werden soll, um eine Paketeigenschaft auszugeben, muss
der name B<in spitzen Klammern> geschrieben werden (d.h. "<name>").
.TP
.BR name ", " category ", " homepage ", " licenses
Name, Kategorie, Homepage and Lizenz des aktuellen Pakets.
.TP
.BR "availableversions:I<VARIABLE>" ", " "availableversions:I<VARIABLE>:I<VARSLOTS>"
Für jede Version wird der Inhalt der Konfigurations/Environment-Variablen B<VARIABLE>
ausgegeben, wobei diese als Formatstring interpretiert wird.
In der zweiten Form, und falls mindestens ein Slot des Pakets nichttrivial ist,
wird I<VARSLOTS> statt I<VARIABLE> benutzt, und die versionen werden entsprechend der Slots sortiert.

Um Missverständnisse zu vermeiden: Es ist nicht möglich, das gewünschte Format direkt nach dem Doppelpunkt anzugeben.
Statt dessen muss das gewünschte Format in einer neuen Variable gespeichert werden, und I<VARIABLE> und I<VARSLOTS>
sind nur die Namen dieser Variablen.

Nützliche Beispiele für I<VARIABLE> sind B<NAMEVERSION>, B<EQNAMEVERSION>,
B<EQNAMEVERSION>, B<ANAMESLOT>, B<ANAMEASLOT>, B<NAMESLOT>, B<NAMEASLOT> oder
B<DATESORT>.
Hierbei sind B<ANAMESLOT> und B<ANAMEASLOT> dazu gedacht, in der zweiten Form
benutzt zu werden, d.h. in B<availableversions:ANAMESLOT:ANAMESLOT> oder
B<availableversions:ANAMEASLOT:ANAMEASLOT> (Mnemonic: B<A>SLOT print slot B<a>lways).
B<NAMESLOT>, B<NAMEASLOT> und B<DATESORT> ist nur für installierte Versionen sinnvoll.
Siehe B<eix --dump> für die genaue Definition der Variablen.
.TP
.BR "markedversions:I<VARIABLE>" ", " "markedversions:I<VARIABLE>:I<VARSLOTS>"
Dies ist analog zu B<availableversions> mit dem Unterschied, dass nur
markierte (verfügbare) Versionen ausgegeben werden.
.TP
.BR "bestversion:I<VARIABLE>" ", " "bestversion*:I<VARIABLE>" ", " "bestslotversions:I<VARIABLE>" ", " "bestslotversions*:I<VARIABLE>" ", " "bestslotupgradeversions:I<VARIABLE>" ", " "bestslotupgradeversions*:I<VARIABLE>"
Dies ist analog zu B<availableversions> mit dem Unterschied, dass nur die
beste Version bzw. die beste Version eines jeden Slots ausgegeben wird.
Für die Varianten mit B<*> werden auch unstabile Versionen akzeptiert.
Für die Varianten mit B<upgrade> werden nur diejenigen Versionen selektiert,
die voraussichtlich nach dem Upgrade erscheinen.
.TP
.B "installedversions:I<VARIABLE>"
Dies ist analog zu B<availableversions> mit dem Unterschied, dass nur
installierte Versionen ausgegeben werden.
.TP
.BR first ", " last ", " slotfirst ", " slotlast ", " oneslot
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Diese Flags können benutzt werden um zu testen, ob gerade die erste oder letzte Version
eine Pakets ausgegeben wird (etwa um Zusatztext in diesen Fällen auszugeben).
Analog, wenn die Ausgabe nach Slot sortiert wird, kann damit getestet werden,
ob die aktuelle Version die erste oder letzte des aktuellen Slots ist,
oder ob es gar überhaupt nur einen Slot gibt.
Alle diese Eigenschaften sind leer, wenn die Bedingung nicht erfüllt ist, sonst 1.
Um die Wiederbenutzung von Code zu erleichtern gilt:
Wenn die Durckausgabe nicht Slot-sortiert ist, dann sind
B<slotfirst>/B<slotlast> äquivalent zu B<first>/B<last>, und B<oneslot> ist 1.
.TP
.BR srcuri ", " havesrcuri
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Sie gibt die B<SRC_URI> einer verfügbaren Version aus bzw. 1, wenn B<SRC_URI> nicht leer ist.
.TP
.BR eapi
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Sie gibt die B<EAPI> einer verfügbaren oder installierten Version aus.
.TP
.BR slot ", " isslot ", " fullslot ", " isfullslot ", " subslot ", " issubslot
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Es wird der Slot/Subslot/beides der aktuellen Version ausgegeben.
B<isslot>, B<isfullslot> und B<issubslot> testen nur of Slot, voller Slot bzw. Subslot
trivial sind und geben in diesem Fall 1 aus (sonst nichts).
.TP
.BR overlayver ", " overlaynum ", " overlayvername ", " virtual
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Es wird der Overlay der aktuellen Version ausgegeben.
B<overlayver> ist der farbige Index des Overlays und leer, falls das gesamte Paket
von nur einem Overlay stammt;
in so einem Fall sollte B<overlaykey> zur Ausgabe des Overlays benutzt werden.
Im Gegensatz dazu enthält B<overlaynum> stets die Nummer des Overlays
(ohne Farben) oder ist leer, falls die Version keinem Overlay entstammt.
B<overlayplainname> ist das Label (Name) (oder Pfad für unbekanntes oder leeres Label) des Overlays;
B<overlayplainame*> betrachtet dabei auch den Hauptbaum als Overlay.
B<overlayvername> und B<overlayvername*> sind analogous, kehren aber mit einem
leeren String zurück, falls das Paket vom selben Overlay stammt.
B<virtual> ist genau dann nichtleer, wenn die Version aus einem virtuellen Overlay kommt.
.TP
.BR versionkeywords ", " versionkeywords* ", " versionekeywords
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Die vollen Keywords der aktuellen Version werden ausgegeben.
Falls die Daten durch das Profile modifiziert wurden, werden die
modifizierten Daten mit B<versionkeywords*> ausgegeben.
Die spezielle Form B<versionekeywords> gibt letzteres aus, falls es sich von
B<versionkeywords> unterscheidet; andernfalls ist es leer.
.TP
.BR isbestupgrade ", " isbestupgrade* ", " isbestupgradeslot ", " isbestupgradeslot*
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Dies expandiert zu 1, falls die aktuelle Version die beste bzw. beste des aktuellen Slots zum Upgraden ist.
Für die Varianten mit B<*> werden auch instabile Versionen berücksichtigt.
.TP
.BR installedversion ", " markedversion
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Expandiert zu 1 oder dem Leerstring, je nachdem ob die aktuelle verfügbare Version installiert bzw. markiert ist.
Für B<markedversions> schlägt dieser Test im Zusammenhang mit <installedversions:...> immer fehl.
.TP
.BR ishardmasked ", " washardmasked ", " isprofilemasked ", " wasprofilemasked ", " ismasked ", " wasmasked ", " isstable ", " wasstable ", " isunstable ", " wasunstable ", " isalienstable ", " wasalienstable ", " isalienunstable ", " wasalienunstable ", " ismissingkeyword ", " wasmissingkeyword ", " isminuskeyword ", " wasminuskeyword ", " isminusunstable ", " wasminusunstable  ", " isminusasterisk ", " wasminusasterisk
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Expandiert zu 1 oder dem Leerstring, je nachdem ob die aktuelle Version (gemäß der
lokelen bzw. Standard-Konfiguration) die entsprechend Stabilitätseigenschaft hat.
.TP
.B isbinary
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Dies ist 1 oder leer, je nachdem ob eine entsprechende Datei mit *.tbz2, *.gpkg.tar oder *.xpak für die Version existiert.
.TP
.B istbz
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Dies ist 1 oder leer, je nachdem ob eine entsprechende Datei mit *.tbz2 für die Version existiert.
.TP
.B isgpkg
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Dies ist 1 oder leer, je nachdem ob mindestens eine entsprechende Datei mit *.gpkg.tar für die Version existiert.
.TP
.B ispak
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Dies ist 1 oder leer, je nachdem ob mindestens eine entsprechende Datei mit *.xpak für die Version existiert.
.TP
.B ismultigpkg
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Dies ist 1 oder leer, je nachdem ob mindestens zwei Dateien mit *.gpkg.tar für die Version existieren.
.TP
.B ismultipak
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Dies ist 1 oder leer, je nachdem ob mindestens zwei Dateien mit *.xpak für die Version existieren.
.TP
.B gpkgcount
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Es enthält die Anzahl der Dateien mit *.gpkg.tar für die Version. Falls keine existiert, ist es leer.
.TP
.B pakcount
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Es enthält die Anzahl der Dateien mit *.xpak für die Version. Falls keine existiert, ist es leer.
.TP
.BR restrict ", " restrictfetch ", " restrictmirror ", " restrictprimaryuri ", " restrictbincheck ", " restrictstrip ", " restricttest ", " restrictuserpriv ", " restrictinstalledsources ", " restrictbindist ", " restrictparallel
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Dies ist 1 oder leer, je nachdem ob eine entsprechendes B<RESTRICT>-Attribut für die Version gesetzt ist.
.TP
.BR properties ", " propertiesinteractive ", " propertieslive ", " propertiesvirtual ", " propertiesset
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Dies ist 1 oder leer, je nachdem ob eine entsprechendes B<PROPERTIES>-Attribut für die Version gesetzt ist.
.TP
.BR depend ", " rdepend ", " pdepend ", " bdepend ", " idepend ", " depend* ", " rdepend* ", " pdepend* ", " bdepend* ", " idepend*
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Es expandiert zum B<DEPEND>, B<RDEPEND>, B<PDEPEND>, B<BDEPEND> bzw. B<IDEPEND> einer vorhandenen Version
(der String wird nach Möglichkeit abgekürzt, falls die Variante mit B<*> benutzt wird).
Die Expansion ist leer, falls B<DEP=true> nicht gesetzt ist (oder bei der Erzeugung der Datenbank nicht gesetzt war).
.TP
.BR havedepend ", " haverdepend ", " havepdepend ", " havebdepend ", " haveidepend ", " havedeps
Wie oben mit dem Unterschied, dass nur 1 ausgegeben wird, wenn der
Wert des entsprechenden String bzw. mindestens eines davon nichtleer ist.
.TP
.BR havemaskreasons ", " maskreasons ", " maskreasons*
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Für verfügbare Versionen gibt B<maskreasons> die Gründe für Maskierungen aus, und B<havemaskreasons> ob es solche Gründe gibt.
Als Trenner werden B<FORMAT_MASKREASONS_LINESKIP> und B<FORMAT_MASKREASONS_SEP> benutzt;
bei B<maskreasons*> werden hingegen B<FORMAT_MASKREASONSS_LINESKIP> und B<FORMAT_MASKREASONSS_SEP> benutzt.
.TP
.BR haveuse ", " use ", " use* ", " use0
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Für verfügbare Versionen gibt B<use> die B<IUSE> Variable aus.
Für installierte Versionen gibt B<use> die B<USE>-Flags an, und ob sie gesetzt sind
(der Inhalt von B<FORMAT_BEFORE_SET_USE>, B<FORMAT_AFTER_SET_USE>, B<FORMAT_BEFORE_UNSET_USE>, B<FORMAT_AFTER_UNSET_USE>
wird an den entsprechenden Stellen ausgegeben).
Die B<use*>-Variante berücksichtigt B<USE_EXPAND>-Variablen separat und gibt sie
unter Berücksichtigung der entsprechenden Variablenwerte von
B<FORMAT_BEFORE_USE_EXPAND_START>, B<FORMAT_BEFORE_USE_EXPAND_END>,
B<FORMAT_AFTER_USE_EXPAND>, B<FORMAT_BEFORE_IUSE_EXPAND_START>,
B<FORMAT_BEFORE_IUSE_EXPAND_END> bzw. B<FORMAT_AFTER_IUSE_EXPAND> an den
entsprechenden Stellen aus.
Die B<use0>-Variante unterdrückt die Ausgabe der B<USE_EXPAND>-Variablen.
B<haveuse> kann benutzt werden, um zu testen, ob die Ausgabe nichtleer ist (in diesem Fall ist die Ausgabe 1, sonst leer).
.TP
.BR requireduse ", " haverequireduse
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Für verfügbare Versionen gibt es die B<REQUIRED_USE>-Variable aus, bzw. B<1> falls diese Variable nicht leer ist.
Die Expansion ist leer, falls B<REQUIRED_USE=true> nicht gesetzt ist (oder bei der Erzeugung der Datenbank nicht gesetzt war).
.TP
.BR "date:I<VAR>"
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Es gibt die Installationszeit aus; das strftime()-Format für die Zeit wird aus der Variablen I<VAR> genommen.
.TP
.BR version, plainversion, revision
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Es ist die reine Versionsnummer (man 5 ebuild: $PVR) als Text.
Bei plainversion with die Versionsnummer ohne Revisionsnummer ausgegeben ($PV),
und bei revision nur die Revisionsnummer ($PR).
Im Gegensatz zu Portage ist die Revision leer, wenn keine spezifiziert ist.
.TP
.BR installed ", " best ", " best*
Ist 1 oder leer, je nachdem of mindestens eine Version des Pakets installiert ist oder eine beste stabile bzw. instabile Version hat.
.TP
.B versionlines
Ist 1 oder leer, je nachdem ob --versionlines aktiv ist.
.TP
.B slotsorted
Ist 1 oder leer, je nachdem ob --versionsort aktiv ist.
.TP
.B color
Ist 1 oder leer, je nachdem, ob Farben/Markers ausgegeben werden.
Falls beispielsweise die Ausgabe auf ein Terminal erfolgt und keine anderweitige
Option angegeben wurde, ist die leer.
.TP
.BR setnames ", " allsetnames
Die Namen aller lokalen Sets, zu denen das Paket gehört, durch Leerzeichen separiert.
Mit B<allsetnames> können auch "system" und "profile" dabei sein.
.TP
.B binary
Ist 1 oder leer, je nachdem, ob mindestens eine Version (verfügbar oder installiert) eine *.tbz2, *.gpkg.tar, oder *.xpak Datei besitzt.
Vgl. die Bemerkungen zu B<--binary>.
.TP
.B mainrepo
Ist 1 oder leer, je nachdem, ob mindestens eine verfügbare Version zum Hauptrepository 0 (typischerweise: gentoo) gehört.
.TP
.BR overlaykey ", " overlayname
Falls alle Versionen zum selben Overlay gehören, wird "[overlaykey]" (in entsprechenden Farben) bzw. "overlaylabel" ausgegeben.
.TP
.BR havevirtual ", " havenonvirtual
Ist 1 or leer, je nachdem ob mindestens eine verfügbare Version aus einem (nicht)virtuellen Overlay stammt.
.TP
.B system
1, falls das Paket zu @system gehört.
.TP
.B profile
1, falls das Paket zu @profile gehört.
.TP
.B world
1, falls das Paket zur world-Datei gehört.
.TP
.B world_sets
1. falls das Paket zu world_sets gehört.
.TP
.B marked
1, falls der Paketname mit der B<--pipe>-Option übergeben wurde (unabhängig davon, ob eine verfügbare Version auf die Maske passt, siehe B<havemarkedversion>)
Dies ist hauptsächlich für Tests sinnvoll.
.TP
.BR havemarkedversion
1 oder leer, je nachdem ob mindestens eine verfügbare Version des Pakets markiert ist.
Es ist möglich, dass ein Paket markiert wurde, obwohl keine der verfügbaren Versionen markiert wurden.
.TP
.BR slots ", " slotted
1, falls es mindestens zwei Slots bzw. mindestens einen nichttrivialen Slotnamen gibt.
.TP
.BR colliuse ", "  colliuse* ", "  colliuse0 ", " havecolliuse
Die gesammelten IUSE-Flags (d.h. ihre Vereinigung) aller verfügbaren Versionen des Pakets, durch Leerzeichen separiert.
Die Variante B<colliuse*> gibt die USE_EXPAND-Variablen separat aus und benutzt dabei
B<FORMAT_BEFORE_COLL_EXPAND_START>,
B<FORMAT_BEFORE_COLL_EXPAND_END> und B<FORMAT_AFTER_COLL_EXPAND>
an den entsprechenden Stellen.
Die Variante B<colliuse0> vermeidet die Ausgabe von USE_EXPAND-Variablen.
havecolliuse ist 1, falls colliuse nichtleer ist; dies ist schneller als colliuse.
.TP
.BR havebest ", " havebest*
1, falls das Paket eine beste stabile/instabile Version hat.
.TP
.BR upgrade ", " upgradeorinstall ", " downgrade ", " recommend ", " recommendorinstall
B<upgrade> ist 1, falls das Paket installiert ist und mindestens ein Slot ein Upgrade ermöglicht
(oder die beste stabile Version ist eine neuer Slot und B<UPGRADE_TO_HIGHEST_SLOT> ist gesetzt).
Die anderen Variablen testen analog, ob für das Paket ein Upgrade oder frische Installation möglich ist,
ob ein Downgrade nötig ist, ob ein Up- oder Downgrade möglich/nötig ist,
bzw. ob ein Up- oder Downgrade oder Frischinstallation nötig/mölich ist.
Die Variable B<RECOMMEND_LOCAL_MODE> entscheidet, ob diese Tests B<LOCAL_PORTAGE_CONFIG> beachten.
.TP
.BR bestupgrade ", " bestupgradeorinstall ", " bestdowngrade ", " bestrecommend ", " bestrecommendorinstall
Wie oben mit dem Unterschied, dass nur die beste stabile Version des Pakets beachtet wird (und nicht alle Slots).
.TP
.BR better ", " worse ", " differ ", " bestbetter ", " bestworse ", " bestdiffer
Dies kann nur in Konditionaltests für B<DIFF_FORMAT_CHANGED> benutzt werden.
B<better> ist 1, falls das neue Paket einen neuen Slot oder eine besssere stabile Version
(or die gleiche beste stabile Version, aber von einem anderen Overlay) für einen Slot als das alte Paket hat.
B<worse> bedeutet analog, dass das alte Paket mindestens einen besseren Slot hatte
oder einen Slot, den es im neuen Paket nicht gibt.
B<differ> bedeutet, dass nicht alle besten stabilen Slots des alten und neuen Pakets übereinstimmen.
Die entsprechenden B<best*>-Versionen haben eine analoge Bedeutung mit dem Unterschied,
dass nur die beste stabile Version berücksichtigt wird (und nicht alle Slots).
Die Variable B<RECOMMEND_LOCAL_MODE> entscheidet, ob diese Tests B<LOCAL_PORTAGE_CONFIG> beachten.
.TP
.BR old... ", " new...
Dies kann nur in B<DIFF_FORMAT_CHANGED> benutzt werden.
Jedem Eigenschaftsname kann ein B<old> oder B<new> vorangestellt werden,
und der Wert entspricht dieser Eigenschaft, wobei die alten bzw. neuen Daten
benutzt werden.
Falls weder B<old> noch B<new> angegeben ist, wird die neue Version angenommen.
Beispielsweise gibt B<oldavailableversions:VAR> die vorerigen verfügbaren Versionen aus
(mit der Variablen B<VAR> als Ausgabeformat), während
B<newavailableversions:VAR> und B<availableversions:VAR> jeweils die
verfügbaren Versionen des aktuellen (d.h. neuen) Pakets ausgeben.
.\" }}}


.\" {{{ -------- Escape-Folgen
.SS Escape-Folgen
.TP
.B \\\\n \\\\r  \\\\t  \\\\b  \\\\a
Diese werden auf die übliche Art wie in printf interpretiert.
Innerhalb von B<FORMATSTRING> werden Tabs in Leerzeichen umgerechnet,
wobei unterstellt wird, dass der B<FORMATSTRING> in UTF8 kodiert ist.

.TP
.B \\\\C\<I<SPALTE>>
Diese spezielle Escape-Folge ist nur in B<FORMATSTRING> zulässig.
Hierbei ist I<SPALTE> eine Zahl (die eingeklammert sein muss).
Während der Ausgabe, wird das Ganze von eix folgendermaßen interpretiert:
Falls die Spalte I<SPALTE> noch während der Ausgabe der aktuellen Zeile
noch nicht erreicht wurde, werden so viele Leerzeichen ausgegben, dass dies der Fall ist.
In gewissem Sinne kann dies also als ein mächtiger Tabulator betrachtet werden,
dessen Interpretation nicht dem Terminal überlassen wird.
For die Berechnung der aktuellen Zeichenposition in der Zeile wird unterstellt,
dass der B<FORMATSTRING> in UTF8 kodiert ist.
.\" }}}

.\" {{{ -------- Farben
.SS Farben
.TP
.BI ( COLORSTRING | COLORSTRING | ... )
Der tatsächlich ausgewählte I<COLORSTRING> hängt von B<COLORSCHEME?> ab.
Er sollte die folgende Gestalt haben:

.TP
.IB MARKER_ODER_COLOR ; MARKER_ODER_COLOR ; ...
B<MARKER_ODER_COLOR> ist entweder ein Markername oder ein Farbname,
optional gefolgt von B<,1> (oder B<,0>) für (nicht-)helle Farbwahl.

Verfügbare Markernamen:
I<none bold italic underline blink inverse>

Verfügbare Farbnamen:
I<default black red green yellow blue purple cyan gray 0 ... 255>

Beachten Sie, dass I<gray> geht nicht auf allen Terminals das Gewünschte tut,
und die Farbnamen I<0> ... I<255> nur auf einem 88/256-Farben-Terminal
sinnvoll interpretiert werden.

Die erste Farbe in I<COLORSTRING> legt die Vordergrund-, die zweite die
Hintergrundfarbe fest.

Wenn eine Vordergrundfarbe festgelegt wird, werden alle Farben und Marker zurückgesetzt.
Der Leerstring ist als die Farbe "default" definiert.
Insbesondere bewirkt B<()>, dass alle Farben und Marker zurückgesetzt werden.

Falls weder Ausgabe noch ein Reset gewünscht ist, kann man den Markennamen B<(none)> wählen.
.\" }}}

.\" {{{ -------- Beispiele
.SS Beispiele:

\fBeix --format '{installed}(yellow,1;underline){else}(yellow,0){}<name>()\\n' ...\fR

Falls das Paket B<...> installiert ist, wird der Name unterstrichen in Hellgelb ausgegeben,
sonst in normalem Gelb.

\fBINSTFORMAT='{first}:{}<version> <date:DATEFORMAT>{!last}\\n\\t{}' DATEFORMAT='%x' eix --format '<category>/<name><installedversions:INSTFORMAT>\\n' 'autom*'\fR

Gibt für jedes B<autom*>-Paket den Kategoriennamen aus sowie, wenn das Paket installiert ist,
die installierten Versionen und die Installationstag.
Man hätte das selbe Ergebnis auch durch Ersetzen von B<{!last}\\t\\n{}> durch B<{first}:{else}\\t\\n{}>
erreichen können, weil es natürlich auf dasselbe hinausläuft, ob B<\\t\\n> am Ende jeder Version
mit Ausnahme der letzten oder am Anfang jeder Version mit Ausnahme der ersten ausgegeben wird.

B<FORMAT='{downgrade}%{FORMAT_ALL}{}' eix -I>

Ausgabe aller installierten Pakete, für die es Downgrade-Empfehlungen gibt.
Beachte, dass B<FORMAT='{downgrade}%{FORMAT}{}'> nicht funktioniert, denn dies
wäre eine selbstreferenzierende Definition bei der verspäteten Ersetzung:
Natürlich kann eine Variable nicht durch eine Ersetzung durch sich selbst expandiert werden.
Aus diesem Grund ist der Inhalt der Variablen B<FORMAT> und ähnlicher Variablen sei eix-0.13.4
sehr einfach: Es ist einfach B<%{FORMAT_ALL}> (und analog für andere Variablen).
Daher kann man einfach die vollständige Definition des ursprünglichen Werts von B<FORMAT> einfügen
(was wir in obigem Beispiel getan haben).

Für kompakte Ausgabe ist es in obigem Beispiel nicht möglich, einfach die Option B<-c>
zu benutzen, denn die Benutzung dieser Option hat nur den Effekt, dass
für den Formatstring die Variable B<FORMAT_COMPACT> statt B<FORMAT> benutzt wird.
Für kompakte Ausgabe muss man also entweder

B<FORMAT_COMPACT='{downgrade}%{FORMAT_ALL_COMPACT}{}' eix -Ic>

benutzen, oder einfacher und mit dem gleichen Effekt:

B<FORMAT='{downgrade}%{FORMAT_ALL_COMPACT}{}' eix -I>

Eine viel einfachere Möglichkeit, die Selbstreferenz zu umgehen,
ist in obigem Beispiel die Benuzung der B<--format> Option:

B<eix --format '{downgrade}%{FORMAT}{}' -I>

bzw. für kompakte Ausgabe

B<eix --format '{downgrade}%{FORMAT_COMPACT}{}' -I>
.\" }}}
.\" }}}

.\" {{{ DATEIEN
.SH "DATEIEN"
.LP
.\" {{{ -------- @SYSCONFDIR@/eix-sync.conf
.SS @SYSCONFDIR@/eix-sync.conf
Diese Datei enthält Kommandos und Konfigurationen für B<eix-sync>.
Kommentarzeilen beginnen mit B<#>.
Die Zeilen haben die folgende Gestalt und werden in der gegebenen Reihenfolge
vor B<emerge --sync> ausgeführt.

Beachten Sie, dass der Inhalt der Variablen B<EIX_SYNC_CONF> an diese Datei angehängt wird.
Per Vorgabe expandiert die Variable zu B<EIX_SYNC_OPTS>, so dass effektiv auch diese Variable an die Datei angehängt wird.
Beide Variablen können benutzt werden, um die Einstellungen aus I<@SYSCONFDIR@/eix-sync.conf> zu modifizieren.
Machen Sie sich bitte bewusst, dass der Code dieser Zeilen bei B<eix-sync> innerhalb einer Shell mit "eval" ausgeführt wird, also Vorsicht bzgl. Sicherheitsproblemen!
.TP
.I Option(en)
Die I<Option(en)> werden als Standardeinstellung für eix-sync ausgeführt (vor allen anderen Optionen).
Wie üblich muss I<Option(en)> mit "B<->" beginnen. I<option(en)> wird von der Shell mit "eval" ermittelt:
Daher also Vorsicht bzgl. Sicherheit! Quoten von Shell-Commando-Trennern ist ebenfalls geboten.
.TP
.I Name
Ruft B<layman -s> I<Name> auf
(<layman> ist Teil des Pakets B<app-portage/layman> und dient zum Syncen von Overlays).
.TP
.BR *
Ruft B<layman -S> auf (d.h. alle Overlays werden mit layman gesynct).
.TP
.BI ! Kommando
Ruft eval I<Kommando> innerhalb des B<eix-sync> Shellskripts auf (in der selben Shell).
I<Kommando> muss erfolgreich beendet werden, sonst gibt B<eix-sync> eine Warnung aus.
(Folglich ist B<!layman> I<Name> mehr oder weniger äquivalent zu I<Name>.)
Es ist möglich das Kommando beispielsweise mit "; true" zu beenden, falls der
Exit-Status ignoriert werdne soll.
Mit der Option B<-F> wird aus der Warnung sogar ein fataler Fehler.
Durch Setzen von B<FATAL_HOOKS> auf einen nichtleeren/leeren Wert kann der
Effekt von B<-F> für alle anschließenden Hooks erzwungen/aufgehoben werden.
Falls nur der aktuelle Hook mit einem Fehler beendet werden soll,
kann man explizit B<die> aufrufen.

Man kann dieses Feature benutzen um z.B. einen Overlay vor dem Aufruf von B<layman>
zu entpacken oder um lokale Fixes auszuführen, nachdem B<layman> aufgerufen wurde.
Hier kann auch die Variable B<have_changed=:> gesetzt werden, um eix-sync mitzuteilen, dass ein Overlay verändert wurde:
Andernfalls wird eix-sync mit Exitstatus 3 anhalten, falls der Hauptbaum nicht verändert wurde.

Im Gegensatz zu früheren eix-Versionen gibt, I<Kommando> nichts aus
(mit einfo kann man Ausgabe erreichen), und I<Kommando> wird nicht in einer
Subshell ausgeführt, d.h. man kann auch Environmentvariablen modifizieren
or eine Ausgabeumleitung starten/beenden.
Der Nachtiel ist, dass man auch leicht versehentlich interne eix-sync-Variablen
oder -Funktionen überschreiben kann; im Zweifelsfall ist es daher besser,
dass Kommando in runde Klammern zu packen (...) um es in einer Subshell auszuführen.
.TP
.BI !! Kommando
Die ist ähnlich zu B<!> I<Kommando> mit dem Unterschied, dass
I<Kommando> immer ausgeführt wird, d.h. selbst wenn die
Optionen -d, -u oder -l benutzt wird.
Es ist dazu gedacht, Environmentvariablen für andere Programme zu setzen.
.TP
.BI ~ Kommando
Dies ist nur für die eix-sync-Optionen B<-s> oder B<-2> wichtig.
In diese Fall wird I<Kommando> vor dem ersten Aufruf von B<rsync> ausgeführt;
die Ausgabe von I<Kommando> wird innerhalb der B<eix-sync> Shell mit "eval" ausgeführt.
Falls I<Kommando> oder die das "eval" der Ausgabe nicht erfolgreich sind,
wird B<eix-sync> eine Warnung ausgeben (oder einen Fehler, falls B<-F> aktiv ist,
d.h. wenn B<FATAL_HOOKS> nichtleer ist).
Dies kann benutzt werden um beispielsweise B<keychain> auszuführen oder
den Inhalt einer I<~/.keychain/*-sh>-Datei oder export-Kommandos für die
aktuellen B<SSH_AUTH_SOCK> und B<SSH_AGENT_PID> auszugeben.
Es ist ebenfalls zulässig, dass die Ausgabe von I<Kommando> ein Kommando ist,
das die Variablen B<PORTAGE_RSYNC_OPTS>, B<PORTAGE_RSYNC_EXTRA_OPTS>,
B<PORTDIR>, B<PORTDIR_SERVER>, B<PORTDIR_CLIENT>, B<SERVER> oder B<CLIENT> modifiziert.
Diese variables werden mit Standardvorgaben gefüllt, wenn I<Kommando> aufgerufen wird
und werden später im B<rsync> Kommando mit ihrer offensichtlichen Bedeutung benutzt.
.TP
.BI @ Kommando
Fügt einen Hook für I<Kommando> hinzu; die tatsächliche Ausführung von I<Kommando>
wird zurückgestellt, bis B<emerge --sync> (erfolgreich) ausgeführt wurde.
.TP
.BI @@ Kommando
Fügt einen Hook für I<Kommando> hinzu; die tatsächliche Ausführung von I<Kommando>
wird zurückgestellt, bis B<emerge --sync> und das darauffolgende B<eix-update> (erfolgreich) ausgeführt wurde.

.TP
Es folgt ein B<schematischer> Überblick über die Reihenfolge der Hooks/Kommandos:

.BR !! " hooks"

.BR "cp @EIX_CACHEFILE@ @EIX_PREVIOUS@"

layman-Aufrufe und B<!>-Hooks in der Reihenfolge von I<@SYSCONFDIR@/eix-sync.conf>

.BR ~ " hooks"

.BR "emerge --sync"

.BR @ " hooks"

.BR "eix-update"

.BR @@ " hooks"

.BR eix-diff

.TP
Einige Beispiele nützlicher Zeilen in I<@SYSCONFDIR@/eix-sync.conf>:
.TP
.B -F
Stets ein Fehlerabbruch, falls layman/hook fehlschlägt.
Dies war bei früheren eix versionen stets der Fall.
.TP
.B -C --ignore-default-opts
Diese Zeile sollte benutzt werden, falls --ask in EMERGE_DEFAULT_OPTS in
/etc/portage/make.conf steht, so dass keine Rückfrage für eix-sync erfolgt.
.TP
.B -r -M
Dies ist nüztlich bei B<PORTDIR_CACHE_METHOD=assign>, falls
B<FEATURES=metadata-transfer> inaktiv oder ausgeschaltet ist
(Letzteres ist bei neueren Portage-Versionen der Fall).
Je nach Bedarf kann auch B<-r> oder B<-M> alleine angegeben werden.
Oder man kann -M durch die Zeile
.TP
.BI @StatusInfo ... [ Statuszeile ]
Ankündigung, dass das nächste Kommando I<...> ist
(Setzt die Statuszeile und gibt die Information für den Benutzer aus).
.TP
.BI @Statusline ...
Wie oben, setzt aber nur die Statuszeile.
.TP
.BI @einfo ...
Wie oben, gibt aber nur die Information für den Benutzer aus.
.TP
.B @eix-remote fetch1
Herunterladen der Remote1-Daten bei jedem Aufruf von B<eix-sync>.
.TP
.B @emerge --regen
ersetzen, um B<emerge --regen> statt B<emerge --metadata> zu benutzen.
.TP
.B @egencache --repo=local --update
Updated den Metadaten-Caches des Overlays mit dem Repository-Namen "local"
bevor eix-update aufgerufen wird, aber nach dem Aufruf von emerge --sync.
Dies kann bei Benutzung der Cachemethode B<metadata-md5> oder B<metadata-flat> für diesen Overlay
sinnvoll sein, falls man sicher sein will, dass der Metadaten-Cache aktuell ist.
Der Nachteil im Falle von B<metadata-flat> ist, dass dieses B<egencache>-Kommando auch dann ausgeführt wird,
wenn "local" nicht verändert wurde (was für locale Repositories typisch ist).
.TP
.B !egencache --repo=foo --update
Updated den Metadaten-Cache des Overlays mit Repository-Namen "foo";
dies kann sinnvoll sein, falls vorher eine Zeile B<foo> oder eine Zeile B<!Kommando zum Updaten von foo> steht,
um diese Repository (durch layman oder ein anderes Kommando) zu updaten,
und falls die Cachemethode B<metadata-flat> für diesen Overlay benutzt werden soll,
obwohl der Metadaten-Cache kaputt oder nicht im Repository enthalten ist.
.TP
.B !!exec >/var/log/eix-sync.log ; chown portage: /var/log/eix-sync.log || true
Sendet die Ausgabe in eine log-Datei (mit korrekten Rechten).
Das "true" am Ende sorgt für Weiterausführung selbst wenn "chown" fehlschlägt.
Falls die Ausgabe des abschließenden B<eix-diff> nicht umgeleitet werden soll,
kann man dies kombinieren mit
.TP
.B @@exec >/dev/tty
Ausgabe von B<eix-diff> auf das Terminal, selbst im Falle von Ausgabeumleitung.
.TP
.B @@exit 0
Keine Ausführung des abschließenden B<eix-diff>.
.TP
.B !!export FORCE_USECOLORS=${FORCE_USECOLORS:-true}
Falls FORCE_USECOLORS nicht in der Environment anders gesetzt wurde,
wird die eix-Ausgabe auch im Falle von Ausgabeumleitung farbig.
.TP
.B ~keychain --quiet ~/.ssh/id_rsa ; cat ~/.keychain/"`hostname`-sh"
.\" }}}

.\" {{{ -------- @SYSCONFDIR@/eixrc
.SS @SYSCONFDIR@/eixrc
Globale Konfigurations-Datei.
Die variablen in B<~/.eixrc> oder von der Environment können
die Variablen aus dieser Datei überschreiben, siehe B<~/.eixrc>.
.\" }}}

.\" {{{ -------- EIXRC
.SS EIXRC
Wenn diese Environmentvariable gesetzt ist, wird ihr Wert anstelle des Dateinamen
I<@SYSCONFDIR@/eixrc> benutzt, um die Konfigurationsdaten zu lesen.
In diesem Fall wird die Datei ~/.eixrc ignoriert
(aber sie kann natürlich ggf. gesourced werden).

.SS EIX_SYNC_OPTS, EIX_SYNC_CONF, EIX_REMOTE_OPTS, EIX_LAYMAN_OPTS, EIX_TEST_OBSOLETE_OPTS
Obwohl diese Variablen typischerweise in ~/.eixrc gesetzt werden
(und daher erst im nächsten Abschnitt beschrieben werden),
werden diese Variablen hier hervogehoben, weil sie besonders sicherheitsrelevant sind:
Sie (oder zumindest Teile von ihnen) werden durch die Shell ausgeführt, wenn die
enstprechenden Skripte ausgeführt werden.
Daher sollte man sicher gehen, dass diese Variablen nicht kompromittiert sind, wenn diese Skripte mit root-Rechten ausgeführt werden.
.\" }}}

.\" {{{ -------- ~/.eixrc
.SS ~/.eixrc
Benutzerspezifische Konfigurationsdatei.
Die Variablen dieser Datei können durch Environmentvariablen überschrieben werden.
In dieser Datei kann eine Shell-ähnliche Syntax benutzt werden, um die folgenden Variablen zu setzen.
Insbesondere können andere Dateien gesourced werden und Hilfsvariablen benutzt werden
um andere Variablen zu setzen.

Dabei ist jedoch zu beachten, dass bei der überlichen Benutzung von Hilfsvariablen
nur die Ergebnisse bei --dump oder --dump-defaults angezeigt werden,
und man kann die eingesetzten Werte nicht durch Environmentvariablen abändern.

Aus diesem Grund gibt es neben der Shell-üblichen Derefenzierung von Variablen
auch eine weitere Möglichkeit der Dereferenzierung mit der
Syntax B<%{>I<VARIABLE>B<}> (the Klammern hier sind nicht-optional).
Diese Syntax bedeutet, dass die Ersetzung so lange verzögert wird, bis
alle Konfigurationsdateien und Environmentvariablen gelesen werden,
und die Ersetzung wird bei --dump oder --dump-defaults nicht durchgeführt.

Dieses Konzept wird verzögerte Ersetzung/Referenz genannt, und es
bietet einige zusätzliche Features:

.\" {{{ -------- Spezielle Symbole
.TP
.B Specielle Symbole zur verzögerten Ersetzung
.RS

.TP
.B " %{%"
Dies muss benutzt werden, falls B<%{> im Variablentext stehen soll
(sonst würde verzögerte Ersetzung aktiv).

.TP
.BI * VARIABLE
Falls die verzögerte Referenz eine Variablennamen benutzt, der mit B<*> beginnt,
so wird dieses B<*> durch B<EIX_>, B<DIFF_>, B<UPDATE_> oder B<DROP_> ersetzt,
je nachdem ob es von B<eix>/B<eix-diff>/B<eix-update> bzw. B<eix-drop-permissions> benutzt wird.
Auf diese Weise kann man verschiedene Standardeinstellungen für diese Programme festlegen.

Beispielsweise wird die verzögerte Referenz B<%{*>I<VARIABLE>B<}> die Expansion
der Variablen B<EIX_>I<VARIABLE>, B<DIFF_>I<VARIABLE>, B<UPDATE_>I<VARIABLE>
bzw. B<DROP_VARIABLE> einfügen.

Die B<\\>- und B<*>-Attribute können kombiniert werden (die Reihenfolge spielt keine Rolle),
und sie können auch mit einem I<APPENDIX> kombiniert werden.

Ein praktisches Beispiel: Falls B<EIX_USER> den Wert "nobody" haben soll,
falls es von B<eix-drop-permissions> (also etwa durch B<eix-remote>)
aufgerufen wird, aber den Vorgabewert "portage" in allen anderen Fällen,
kann man folgendes Setzen:

B<EIX_USER=%{*EIX_USER}>

B<EIX_EIX_USER=portage>

B<DIFF_EIX_USER=portage>

B<UPDATE_EIX_USER=portage>

B<DROP_EIX_USER=nobody>

.TP
B<\\>I<VARIABLE>
Falls eine verzögerte Referenz einen Variablennamen benutzt, der mit B<\\> beginnt,
so werden alle \\ or [\\n\\r\\t ] Zeichen des (expandierten) Inhalts von
I<VARIABLE> als escaped betrachtet.

Insbesondere kann die verzögerte Referenz B<%{\\>I<VARIABLE>B<}> in
Stiring-List-Variablen wie B<CACHE_METHOD> oder B<EIX_LOCAL_SETS> benutzt werden
und stellt dabei sicher, dass I<VARIABLE> höchstens einen Eintrag "so wie er ist"
erzeugt, selbst dann, wenn dieser Eintrag Leerzeichen oder des Zeichen \\ enthält.

Die B<\\>- und B<*>-Attribute können kombiniert werden (die Reihenfolge spielt keine Rolle),
und sie können auch mit einem I<APPENDIX> kombiniert werden.

.TP
.BI * VARIABLE " " APPENDIX
Dies wird nur dann erkann, wenn I<APPENDIX> mit einem der Zeichen B<,> oder B<;> beginnt.
In diesem Fall wird B<APPENDIX> and den Inhalt von B<VARIABLE> angehängt sowie vor jedes B<|>-Zeichen dieses Inhalts.
(Der B<APPENDIX> kann mit den B<\\>- und B<*>-Attributen kombiniert werden.)
B<APPENDIX> wird unverändert übernommne, und er darf nicht das Zeichen B<}> enthalten.
Der Zweck ist es, das Schreiben von Farben zu vereinfachen.
Beispiel:

B<COLOR_DEFAULT=blue|27>

B<FORMAT="(%{COLOR_DEFAULT,1)A (%{COLOR_DEFAULT;invert})B">

B<BAD_FORMAT=(%{COLOR_DEFAULT},1;invert)A>

In diesem Beispiel wird B<FORMAT> zu

.B (blue,1|27,1)A (blue;invert|27;invert)B

expandieren, B<BAD_FORMAT> hingegen zu

.B (blue|27,1;invert)A

Letzteres führt wahrscheinlich nicht zum beabsichtigten Ergebnis, falls B<COLORSCHEME?=0> ist.
.RE
.\" }}}

.\" {{{ -------- Konditionelle Blocks in verögerten Referenzen
.TP
.B Konditionelle Blocks in verögerten Referenzen
Falls einige Variableninhalte in Abhängigkeit einer (Booleschen) Variablen
ganz anders aussehen sollen, können konditionelle Blocks benutzt werden.

Dies ist analog zu konditionellen Blocks im FORMATSTRING:
Wenn die referenzierte Variable schließlich zum Booleschen Wert "true"
expandiert (B<true>/B<1>/B<yes>/B<y>/B<on>) (bzw. zu etwas Nichtleerem,
falls I<VARIABLE> ein zusätzliches B<?> vorangestellt wird), so ist
das Ergebnis wahr, und der entsprechende Block des Strings wird expandiert.
Konditionen können negiert werden, so dass  der else-Teil expandiert wird,
wenn die Bedingung wahr ist und der if-Teil, wenn die Bedingung falsch ist.
Der else-Teil kann auch vollständig weggelassen werden.
Die speziellen Variablennamen B<*>I<VARIABLE> (statt I<VARIABLE>)
können auch hier benutzt werden.

.RS
.TP
.BI %{? VARIABLE } TCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> zu "true" expandiert.

.TP
.BI %{?? VARIABLE } TCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> zu einem nichtleeren String expandiert.

.TP
.BI %{! VARIABLE } TCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> nicht zu "true" expandiert.

.TP
.BI %{!? VARIABLE } TCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> zu einem leeren String expandiert.

.TP
.BI %{? VARIABLE } TCODE %{else} FCODE %{}
Expandiert zu I<TCODE> falls I<VARIABLE> zu "true" expandiert, sonst zu I<FCODE>.

.TP
.BI %{?? VARIABLE } TCODE %{else} FCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> zu einem nichtleeren String expandiert, sonst zu I<FCODE>.

.TP
.BI %{! VARIABLE } TCODE %{else} FCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> nicht zu "true" expandiert, sonst zu I<FCODE>.

.TP
.BI %{!? VARIABLE } TCODE %{else} FCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> zu einem leeren String exapndiert, sonst zu I<FCODE>.

Ein konditioneller Block muss vollständig in einer einzigen Variable stehen,
d.h. es ist nicht möglich, beispielsweise das B<%{}> Zeichen aus einer anderen Variable
über verzögerte Ersetzung zu erhalten (aber in I<TCODE>/I<FCODE> können wiederum
verzögerte Referenzen enthalten sein).
.RE
.\" }}}

Beachten Sie, dass Variablen, die zu verzögerten Ersetzung benutzt werden, nur dann
mit --dump ausgegeben werden, wenn sie tatsächlich benutzt werden (d.h. in einer anderen
Variable dereferenziert werden).
Falls sie trotzdem ausgegeben werden sollen, etwa für Kommentare oder leichtere spätere Änderungen,
so können Referenzen auf sie in der B<DUMMY>-Variable gespeichert werden.

Die folgenden Variablenliste enthält nicht die Variablen, die in verspäteter Ersetzung benutzt werden.
Um eine Beschreibung der Letzteren (und ihrer Vorgabewerte) zu erhalten, benutzen Sie bitte B<eix --dump>.

Einige Bemerkungen zur Stabilität der Namen bzgl. zukünftiger eix-Versionen:
Soweit möglich und sinnvoll, wird versucht, die Bedeutung aller Namen beizubehalten,
zumindest für die im folgenden aufgezählten Variablen.
Bei Variablen zur verspäteten Ersetzung sind Änderungen wahrscheinlicher.
Als Faustregel gilt: Je "elementarer" eine Variable ist (beispielsweise eine
Variable, die nur ein einzelnes Zeichen definiert), desto unwahrscheinlicher ist,
dass Sie sich in zukünftigen eix Versionen ändert oder entfernt wird.
Hingegen Variablen zur verzögerten Ersetzung im "Mittelbau" (die also wiederum
selbst andere Variablen zur verzögert Ersetzung benutzen), haben eine
größere Wahrscheinlichkeit in zukünftigen eix-Versionen in ihrere Bedeutung
geändert oder entfernt zu werden - je nachdem, welche Erweiterungen im
Format für gewisse zukünftige Erweiterungen von eix notwendig sein werden.

.TP
.B DUMMY " " (string)
Diese Variable hat keinen direkten Einfluss auf das Programm, aber ihr Inhalt
kann benutzt werden, um verzögerte Ersetzungen zu (ansonsten unbenutzten) Variablen
zu sammeln, so dass diese mit --dump oder --dump-defaults ausgegeben werden.

.TP
.BR WIDETERM " " (true / false / auto / leer)
Diese Variable wird nur zur verzögerten Ersetzung benutzt.
Sie legt fest, ob ein breites Terminal (breiter als 80 Spalten) vorliegt.
Falls B<WIDETERM> leer oder B<auto> ist, wird B<COLUMNS> benutzt, um den Wert
zur verzögerten Ersetzung festzulegen.

.TP
.B COLUMNS " " (integer / auto / leer)
Dies legt die Terminalbreite fest, wenn B<WIDETERM> leer ist.
Wenn B<COLUMNS> leer oder B<auto> ist, wird eine Heuristik für B<WIDETERM> benutzt.
Wenn die Heuristik fehlschlägt ist der eingesetzte Wert von B<WIDETERM> leer
(was sich bzgl. verzögerter Ersetzung wie B<false> verhält).

.TP
.BR EIX_SYNC_OPTS ", " EIX_SYNC_CONF " " (string)
Der Inhalt von B<EIX_SYNC_CONF> wird an die Datei I<@SYSCONFDIR/eix-sync.conf> angehängt.
Weitere Details finden sich in der Beschreibung jener Datei.
Per default ist B<EIX_SYNC_CONF> eine verzögerte Ersetzung von B<EIX_SYNC_OPTS>,
so dass typischerweise B<EIX_SYNC_OPTS> zum gleichen Zweck genutzt werden kann.
Vorsicht: Wenn eine dieser Variablen kompromittiert ist, kann beim Aufruf von
B<eix-sync> mit Root-Rechten nahezu alles passieren!
Diese Variablen müssen im Falle einer Benutzung vorsichtig gequotet werden.

.TP
.BR EIX_REMOTE_OPTS ", " EIX_LAYMAN_OPTS ", " EIX_TEST_OBSOLETE_OPTS " " (string)
Der Inhalt dieser Variablen wird einem "eval" unterzogen und als Argumente für die Skripte
B<eix-remote>, B<eix-layman> bzw. B<eix-test-obsolete> benutzt.
Diese Variablen sind also vorsichtig zu quoten. Vorsicht vor Sicherheitsrisiken!

.TP
.BR EIXRC_SOURCE " " (string)
Dieser Pfad wird bei Source-Kommandos in I<@SYSCONFDIR@/eixrc> vorangestellt.
Er ist gedacht, in der Environment gesetzt zu werden, aber er kann auch in I<@SYSCONFDIR@/eixrc> gesetzt werden.
Im letzte Fall wird er alle Settings aus der Environment überschreiben, sobald er gelesen wird,
so lange bis alle Dateien gesourced wurden.
Beachten Sie, dass noch keine verzögerte Ersetzung stattfindet, wenn diese Variable aktiv wird.

.TP
.BR EIX_PREFIX " " (prefix-string) " (prefix-string heißt, dass dies ein String ist, aber wenn es den Wert '/' hat, wird dieser geändert zu '')"

Dies ist i.W. dazu gedacht in der Environment gesetzt zu werden, falls eine chroot benutzt wird:
Es wird dem Pfad vorangestellt, in dem I<@SYSCONFDIR@/eixrc> gesucht wird.
Falls es nicht gesetzt ist, wird der Wert der Environment-Variable B<PORTAGE_CONFIGROOT> vorangestellt.
Der Vorgabewert (typischerweise leer) dieser Variable wird benutzt, falls keines
von beiden in der Environment gesetzt ist.

Darüberhinaus wird dieser Variable in der verzögerten Ersetzung benutzt,
um den Präfix einer Menge von Pfaden der folgenden Variablen zu setzen;
mit B<eix --dump> erfährt man im Detail, in welchen anderen Variablen sie vorkommt.

.TP
.BR EPREFIX " " (prefix-string)
Der Vorgabewert dieser Variable kommt von EIX_PREFIX, wobei ein
zur Compilezeit angegebener Vorgabewert (für prefix-portage) angehängt wird.
Diese Variable hat alleine keine Bedeutung, aber sie wird
mit verzögerte Ersetzung benutzt, um den Präfix einer Reihe von Pfaden
in den folgen Variablen festzulegen (wenn ihr Vorgabewert nicht geändert wird);
mit B<eix --dump> erfährt man im Detail, in welchen anderen Variablen sie vorkommt.
In den derzeitigen Vorgabewerten beeinflusst sie alle Pfade mit den folgenden Ausnahmen:

.TP
.BR TMPDIR " " (string)
Dies wird zur verzögerten Ersetzung in B<EIX_TMPDIR> benutzt.
eix exportiert diese Variable und initialisiert sie dabei auf den Wert von
B<EIX_TMPDIR>. Der Wert ist typischerweise durch die Environment gesetzt.

.TP
.BR EIX_TMPDIR " " (string)
Wenn diese Variable nicht leer ist, wird dieses Verzeichnis statt I</tmp>
für Temporärdateien benutzt. eix exportiert diese Variable als B<TMPDIR>.
Der voreingestellte Wert ist verzögerte Ersetzung durch B<TMPDIR>.

.RS
.RS

.B @BINDIR@/eix-functions.sh

.B ~/.eixrc

.BR "Cachedateipfad" "(e) aus der Kommandozeile"

.BR PORTAGE_PROFILE " (nur die variable, nicht der Link)"

.B PORTDIR

.B Overlay-Pfade
.RE

Die letzten drei Punkte können durch B<EPREFIX_TREE> modifiziert werden.

Der Zweck von B<EPREFIX> ist es, eine quasi-chroot analog zu prefix-portage zu erlauben.
.RS

.BR ROOT " " (prefix-string)

.BR EPREFIX_TREE " " (prefix-string)

.BR EPREFIX_ROOT " " (prefix-string)
.RE

Dies sind tatsächlich nicht interne Variablen von eix, sondern sie werden nur
zur verzögerten Ersetzung für die folgenden Variablen analog zu B<EPREFIX> benutzt (siehe oben).

Der Zweck von B<ROOT> ist es, ungefähr Portage's Nutzung dieser Variablen wiederzuspiegeln.
Beachte, dass die Variablen in /etc/portage/make.conf keinen Einfluss auf eixs Konfigurationsvariablen haben.
Insbesondere wird ein Kommando B<ROOT=>I<something> in /etc/portage/make.conf keinen Einfluss auf eix haben.
Es muss statt dessen in der Environment oder eine Konfigurationsdatei von eix gesetzt werden.

Man kann leicht konfigurieren, auf welche Pfade die Variablen B<EPREFIX> oder B<ROOT> Einfluss nehmen:
Man muss in den entsprechenden folgenden Variablen nurr entsprechend die verzögerte Referenz
B<%{EPREFIX}>, B<%{ROOT}>, nichts, oder B<%{EPREFIX_ROOT}> benutzen.
(Letzteres ist seinerseits als verzögerte Referenz definiert ist, so dass
man leicht ändern kann was geschehen soll, falls B<EPREFIX> und B<ROOT> beide
nichtleer sind: Man kann sie aneinandersetzen oder nur eines davon benutzen).
Man kann natürlich auch andere Variablen zur verzögerte Ersetzung benutzen;
beispielsweise könnte man

.B EIX_CACHEFILE=%{EPREFIX_PROFILE}@EIX_CACHEFILE@

setzen, wenn man will, dass die Cachedatei von eix (nur) vom PROFILE-Wurzelverzeichnis abhängen soll.
.RE

.TP
.BR PORTAGE_CONFIGROOT " " (prefix-string)
Dieser Pfad wir /etc-Pfaden vorangestellt.
Der Zweck ist es, PORTAGE_CONFIGROOT auf analoge Weise wie portage zu berücksichtigen.
Falls diese Variable in der Environment gesetzt wird, wird sie auch den Pfad ändern,
in dem I<@SYSCONFDIR@/eixrc> gesucht wird.
(Beachte, dass das Lesen von I<@SYSCONFDIR@/eixrc> geschieht, bevor verzögerte Ersetzung aktiv wird.)

.TP
.BR MAKE_GLOBALS " " (string)
Falls diese Datei existiert, so wird sie anstelle von
B<%{PORTAGE_CONFIGROOT}/etc/make.globals>
benutzt.
Der Vorgabewert entspricht dem Verhalten von >=portage-2.2*

.TP
.BR PORTAGE_REPOS_CONF " " (string)
Diese Datei wird zur Vorgabe der Repository-Informationen eingelesen.
Erst danach wird I</etc/portage/repos.conf> berücksichtigt.

.TP
.BR PORTAGE_REPOSITORIES " " (string)
Wenn diese Variable nichtleer ist, wird ihr Inhalt ähnlich wie von Portage
anstelle aller repos.conf-Dateien benutzt.

.TP
.BR EPREFIX_PORTAGE_EXEC " " (prefix-string)
Dieser Pfad kann als Präfix für I</usr/bin/ebuild> benutzt werden.

.TP
.BR EPREFIX_SOURCE " " (prefix-string)
Dieser Pfad wird allen Pfaden vorangestellt, die als Argumente von Source-Kommandos
in /etc/portage/make.conf und /etc/make.globals auftauchen.

.TP
.BR EPREFIX_INSTALLED " " (prefix-string)
Die wird allen Pfaden vorangestellen, in den eix Informationen über installierte Pakete sucht.

.TP
.BR EPREFIX_PORTAGE_CACHE " " (prefix-string)
Dieser Präfix wird dem Portage Cache vorangestellt.

.TP
.BR EPREFIX_ACCESS_OVERLAYS " " (prefix-string)
Dieser Präfix wird Overlays vorangestellt, sobald auf ihre Dateien zugegriffen wird.

.TP
.BR EPREFIX_PORTDIR " " (prefix-string)
Dieser Pfad wird B<PORTDIR> vorangestellt.

.TP
.BR EPREFIX_OVERLAYS " " (prefix-string)
Dieser Präfix wird allen Einträgen von B<PORTAGE_OVERLAY> vorangestellt.

.TP
.BR EPREFIX_PROFILE " " (prefix-string)
Dieser Präfix wird B<PORTAGE_PROFILE> (die Variable, nicht der Link) vorangestellt.

.TP
.BR EPREFIX_VIRTUAL " " (prefix-string)
Dies wir Overlays in der eix Datenbank bei Tests, ob sie existieren, vorangestellt.

.TP
.BR EIX_CACHEFILE " " (string)
Die eix-Cachedatei, normalerweise B<%{EPREFIX}@EIX_CACHEFILE@>

.TP
.BR EIX_PREVIOUS " " (string)
Die alte eix-Cachedatei für eix-diff und eix-sync,
normalerweise B<%{EPREFIX}@EIX_PREVIOUS@>

.TP
.BR EIX_REMOTE1 ", " EIX_REMOTE1 " " (string)
Die eix-Cachedatei, die bei B<-R> bzw. B<-Z> benutzt wird.
Falls der String nichtleer ist, benutzt eix-remote diese Datanbank zur Ausgabe.
Der Vorgabewert ist B<%{EPREFIX}@EIX_REMOTECACHEFILE1@> bzw. B<%{EPREFIX}@EIX_REMOTECACHEFILE2@>

.TP
.BR REMOTE_DEFAULT " " (integer)
Der Wert 1, 2 oder 0 bedeutet, dass als Vorgabe die Option
B<-R> bzw. B<-Z> bzw. weder noch aktiviert ist.

.TP
.BR EIX_REMOTEARCHIVE1 ", " EIX_REMOTEARCHIVE2 " " (string)
Eine lokale Kopie des Remote-Archivs, auf das eix-remote zugreift.
Falls es leer ist, werden nur Temporärdateien benutzt.

.TP
.BR EBUILD_DEPEND_TEMP " " (string)
Pfad zur Datei, die von B<ebuild depend> generiert wird.

.TP
.BR EIX_WORLD " " (string)
Die Datei, die eix als world-Datei betrachtet.
Beachte, dass diese Datei normalerweise nur für Mitglieder der Gruppe portage lesbar ist.
Um diese Privilegien zu vermeiden, kann B<SAVE_WORLD> benutzt werden.

.TP
.BR EIX_WORLD_SETS " " (string)
Die Datei, die eix als world_sets benutzt.
Es gilt dasselbe wie für B<EIX_WORLD>

.TP
.BR EIX_LOCAL_SETS " " "(Stringliste)" "(die Bedeutung von Stringliste wird im nächsten Absatz erklärt)"
Dies ist eine Liste von Verzeichnissen, die lokal definierte Sets enthalten.
Die Verzeichnisse werden in der gegebenen Ordnung gelesen;
Dateien mit Setnamen, die früher gelesen wurden, werden ignoriert:
In diesem Sinne haben frühere Einträge inB<EIX_LOCAL_SETS> eine höhere Präzedenz.

Relative Verzeichnisse (d.h. solche, die nicht mit B</> beginnen) werden relativ zu B<$PORTDIR> aufgefasst.
Einträge in B<EIX_LOCAL_SETS>, die mit dem speziellen Zeichen B<*> beginnen, werden auf spezielle Art interpretiert:
Sie werden als mehrere Einträge interpretiert, wobei das B<*>-Zeichen die
Pfade zu den Overlays in umgekehrter Ordnung durchläuft
(umgekehrte Ordnung deswegen, weil in gewissem Sinne frühere Einträge
in B<EIX_LOCAL_SETS> spätere überschreiben, während man für B<PORTDIR_OVERLAY>
das Umgekehrte erwartet).

Die Vorgabe dieser Variable enthält B</etc/portage/sets>, B</etc/portage/sets.eix>, B<sets>
(d.h. ungefähr B<$PORTDIR/sets> nach dem vorherigen Absatz),
B<*/sets> (d.h. ungefähr B<$PORTIDR_OVERLAY/sets> nach dem vorherigen Absatz)
sowie B<%{EIX_LOCAL_SETS_ADD}>.
Der Grund für Letzteres ist, dass man einfach zusätzliche Verzeichnisse
zur Variablen B<%{EIX_LOCAL_SETS_ADD}> in I<@SYSCONFDIR@/eixrc> hinzufügen kann.
Gründe dafür sind beispielsweise, wenn man in /etc/portage/sets.conf oder in der sets.conf Datei eines Overlays
ein weiteres multiset-Verzeichnis definiert,
z.B. für einen Overlay oder für die Behandlung mit "world-candidate = False".

Für alle Stringlisten-Variablen sind die erlaubten Trenner zwischen verschiedenen Einträgen [ \\t\\r\\n].
Falls solch ein Trenner innerhalb eines Eintrags benutzt werden soll, so kann man ihn durch Voranstellen von B<\\> escapen.
Natürlich müssen alle B<\\>-Zeichen analog escaped werden, weil Escapes von Escapes oder Trennzeichen entfernt werden.
Falls eine Variable so, wie sie ist, als einzelner Eintrag eingefügt werden soll, kann man verzögerte Ersetzung benutzen:
B<%{\\>I<VAR>B<}> wird den Wert der Variablen I<VAR> einfügen, wobei alle Zeichen aus [\\ \\t\\r\\n] escaped werden
(mehr Details stehen im Abschnitt zur verzögerten Ersetzung).

.TP
.BR EAPI_REGEX
Dieser reguläre Ausdruck soll auf bekannte EAPIs in .ebuild-Namensanhängen haben,
die gemäß GLEP 55 bekannt sein sollen.
Es kann notwendig sein, diesen Ausdruck lokal entsprechend der installierten Portage-Version zu modifizieren
(um sicherzugehen, dass die installierte Portage-Version die entsprechenden EAPIs parsen kann).
Ein Ausnahmefall ist, wenn diese Variable leer ist:
In diesm Fall werden alle ebuilds mit EAPI-Anhängen ignoriert.

.TP
.BR SAVE_WORLD " " (true / false)
Falls dies gesetzt ist, werden die Informationen der world-Datei in @EIX_CACHEFILE@ gespeichert.
Vorsicht:
Dies bedeutet, dass jeder, der diese Datei lesen kann auch Informationen über die world-Datei hat!

.TP
.BR CURRENT_WORLD " " (true / false)
Falls diese Variable falsch ist, wird die Information über die world-Datei aus @EIX_CACHEFILE@ benutzt,
selbst dann, wenn die aktuelle world-Datei lesbar sein sollte.
Andernfalls wird die aktuelle world-Datei (wenn sie lesbar ist), diese Information überschreiben.

.TP
.BR EIX_USER ", " EIX_GROUP ", " EIX_UID ", " EIX_GID " " (string / integer)
B<eix>, B<eix-diff>, B<eix-update>, B<eix-drop-permissions> und B<eix-remote>
ändern so früh wie möglich ihre Rechte zu B<EIX_USER>/B<EIX_GROUP>
(bzw. zu den ID-Zahlen B<EIX_UID>/B<EIX_GID>, falls die vorherigen Variablen
keinen gültigen Namen enthalten).
Um dies zu verhinden, kann ein ungültiger Namen (etwa der leere Name) und
eine nicht-positive ID-NUmmer benutzt werden.

Falls B<EIX_GROUP> gültig und B<EIX_GID> positiv ist, dann wird auch die
Gruppenlist nach der folgenden Regel geändert:
Falls B<EIX_USER> ein gültiger Name ist, wird die volle Gruppenliste
dieses Benutzers gewählt; andernfalls schrumpft die Gruppenliste auf
einen einzelnen Eintrag zusammen.

.TP
.BR REQUIRE_DROP " " (true / false / root)
Der Wert B<true> bedeutet, dass die Rechteänderungen entsprechend von
B<EIX_{USER,GROUP,UID,GID}> erfolgreich sein müssen, vgl. B<DROP_FATAL>.
Im Falle des Werts B<root> muss dies nur dann der Fall sein, wenn die
aktuelle UID den Wert 0 hat.

.TP
.BR NODROP_FATAL " " (true / false)
Wenn die Voraussetzung entsprechend B<REQUIRE_DROP> fehlschlägt, wird
mit einem Fehler abgebrochen (B<true>) bzw. nur eine Warnung ausgegeben.

.TP
.BR PORTAGE_ROOTPATH " " (string)
Falls nichtleer, wird dies Variable unverändert an ebuild.sh für die Cachemethode B<ebuild*> übergeben.

.TP
.BR DEFAULT_ARCH " " (string)
Der Vorgabewert für ARCH, falls keiner im Profile spezifiert ist.

.TP
.BR NOFOUND_STATUS " " (integer)
Dieser Wert wird als Exit-Status benutzt, falls kein Paket passt.
Der Wert von B<COUNT_ONLY_PRINTED> wird dabei berücksichtigt.

.TP
.BR MOREFOUND_STATUS " " (integer)
Dieser Wert wird als Exit-Status für 2 oder mehr Treffer benutzt.
Der Wert von B<COUNT_ONLY_PRINTED> wird dabei berücksichtigt.

.TP
.BR EIX_LIMIT ", " EIX_LIMIT_COMPACT " " (integer)
Als Sicherheitsmaßnahme für Vertipper werden auf dem Terminal niemals mehr
als die entsprechende Anzahl von Paketen ausgegeben:
Es gibt zwei verschiedene Variablen, je nachdem, ob B<--compact> aktiv ist oder nicht.
Es gibt keinen solchen Limit, falls die Ausgabe nicht auf das Terminal geht,
oder falls die Variable den Wert B<0> enthält.

.TP
.BR QUICKMODE " " (true / false)
Bestimmt, ob für eix und eix-diff die Option B<--quick> die Vorgabe ist.

.TP
.BR CAREMODE " " (true / false)
Bestimmt, ob für eix und eix-diff die Option B<--care> die Vorgabe ist.

.TP
.BR USE_BUILD_TIME " " (true / false)
Entscheidet, ob der BUILD_TIME-Eintrag (falls existent) der Portage Datenbank
benutzt werden kann anstelle des Zeitstempels des Verzeichnisses
(das normalerweise die Installationszeit trägt).
Der Unterschied ist für gewöhnlich nur für Pakete wichtig, die aus einem
*.tbz2, *.gpkg.tar, oder *.xpak installiert wurden, aber in den meisten Fällen
ist die BUILD_TIME relevanter (und auch verlässlicher).
Unglücklicherweise ist die BUILD_TIME nur für Pakete verfügbar, die
mit >=portage-2.2_rc63 gebaut und installiert wurden.
Der B<eix-installed [no-]buildtime> Test kann herausfinden, für welche
Versionen dies (nicht) der Fall ist.
Die BUILD_TIME zu lesen ist stets langsamer als das Lesen des Zeitstempels
der Verzeichnisses (selbst dann, wenn die BUILD_TIME nicht verfügbar ist).
Daher kann es sinnvoll sein, diese Variable auf B<false> zu setzen, wenn die
Geschwindigkeit wichtiger ist als eine verlässliche BUILD_TIME-Information.

.TP
.BR QUIETMODE " " (true / false)
Bestimmt, ob für eix und eix-diff die Option B<--quiet> die Vorgabe ist.

.TP
.BR PRINT_APPEND " " (string)
Dieser String wir an die Ausgabe von B<--print>.
Standard Escape-Sequences wie \\n in diesem String werden interpretiert.
Der default ist ein Zeilenvorschub, um in interaktiven Shells eine
vernünftige Ausgabe zu erzeugen.
Beachte, dass die Kommando-Ersetzung in Shellskripten Leerzeichen am Ende
der Ausgabe entfernt, so dass dieser Zeilenvorschub nicht schadet
(Leerzeichen/Zeilenvorschübe  am Ende der Variable werden in Skripten
ja ohnehin entfernt).
Wenn man also in einem Shellskript Variablen von eix lesen will, ohne
ev. deren Leerzeichen am Ende zu unterdrücken, sollte man ein sichtbares
Zeichen für PRINT_APPEND benutzen, beispielsweise so etwas wie
B<VAR=`PRINT_APPEND=x eix --print VAR` ; VAR=${VAR%x}>

.TP
.BR DEFAULT_FORMAT " " (normal / compact / verbose)
Legt fest, ob B<--compact> oder B<--verbose> als Vorgabe gewählt wird.
Da diese Variable vom Benutzer in B</etc/eixrc> oder B<~/.eixrc> geändert
werden kann, kann dies ungewünschte Nebenwirkungen auf Skripte haben, die
B<FORMAT> mit der Intention setzen, einen festen B<FORMATSTRING> vorzugeben:
Solche Skripte sollten besser die B<--format> Option benutzen (die seit
eix-0.29.6 B<DEFAULT_FORMAT> ignoriert), die B<--normal> Option benutzen
(die seit eix-0.29.6 existiert) und/oder B<DEFAULT_FORMAT=normal> exportieren.

.TP
.BR DIFF_ONLY_INSTALLED " " (true / false)
Legt fest, ob eix-diff nur Versionsänderungen installierter Pakete betrachtet.

.TP
.BR DIFF_NO_SLOTS " " (true / false)
Legt fest, ob eix-diff Slots für Versionsänderungen betrachtet.

.TP
.BR DIFF_SEPARATE_DELETED " " (true / false)
Legt fest, ob eix-diff gelöschte Pakete getrennt auflistet.
Andernfalls wird eix-diff gelöschte und geänderte Pakete "alphabetisch"
auflisten.

.TP
.BR NO_RESTRICTIONS " " (true / false)
Falls nicht gesetzt, werden keine RESTRICTION- und PROPERTIES-Daten ausgegeben.

.TP
.BR RESTRICT_INSTALLED " " (true / false)
Legt fest, ob fetch- und mirror-Restriktionen installierter Pakete beachtet
werden sollen.

.TP
.BR CARE_RESTRICT_INSTALLED " " (true / false)
Legt fest, ob fetch- und mirror-Restriktionen installierter Versionen stets
von Disk gelesen werden sollen, selbst dann wenn sie von einer
entsprechenden verfügbaren Version bekannt sind.
Dies ist langsamer, aber zuverlässiger, d.h. es wird auch herausfinden,
ob sich die Restriktionen geändert haben.

.TP
.BR DEPS_INSTALLED " " (true / false)
Legt fest, ob Abhängigkeitsinformationen installierter Versionen stets
von Disk gelesen werden sollen, selbst dann wenn sie von einer
entsprechenden verfügbaren Version bekannt sind.
Die Option B<--deps-installed> tut dasselbe.

.TP
.BR DEP " " (true / false)
Dieser Wert entscheidet, ob die Werte der Variablen
B<DEPEND>, B<RDEPEND>, B<PDEPEND>, B<BDEPEND>, B<IDEPEND> (die z.B. mit eix -lv gezeigt werden könnten)
tatsächlich benutzt und gespeichert werden sollen.
Im positiven Fall verdoppelt sich ungefähr der Disk- und Speicherbedarf von eix.

.TP
.BR SRC_URI " " (true / false)
Dieser Wert entscheidet, ob die Variable
B<SRC_URI> (die z.B. mit eix -lv gezeigt werden könnten)
tatsächlich benutzt und gespeichert werden sollen.
Im positiven Fall verdoppelt sich ungefähr der Disk- und Speicherbedarf von eix.

.TP
.BR REQUIRED_USE " " (true / false)
Dieser Wert entscheidet, ob die Variable B<REQUIRED_USE> (die z.B. mit eix -l gezeigt werden könnte)
tatsächlich benutzt und gespeichert werden sollen.
Im positiven Fall erhöht dich der Disk- und Speicherbedarf von eix.

.TP
.BR FORMAT ", " FORMAT_COMPACT ", " FORMAT_VERBOSE " " (string)
Das normale, kompakte bzw. ausführliche Layout für die Ausgabe von B<eix>.
Siehe B<FORMATSTRING>.
Wenn eine dieser Variablen in einem Skript gesetzt wird, empfiehlt es sich,
gleichzeitig den entsprechenden Wert für B<DEFAULT_FORMAT> zu setzen.

Seit eix-0.13.4 expandieren diese Variablen als Vorgabe über verzögerte Ersetzung
zu den Variablen B<FORMAT_ALL>, B<FORMAT_ALL_COMPACT> bzw. B<FORMAT_ALL_VERBOSE>.
Der Zweck dieser einfachen Definition ist, dass es leicht ist, auf die
Vorgabedefinitionen mit verzögerter Ersetzung zu verweisen,
wenn die Definition von B<FORMAT> geändert werden soll.

.TP
.B FORMAT_TEST_OBSOLETE (string)
Das Format, das vom Script B<eix-test-obsolete> benutzt wird;
der Vorgabewert ist die verzögerte Ersetzung von B<FORMAT_ALL_COMPACT>.
Es ist nicht erlaubt here verzögerte Ersetzung von B<FORMAT> zu benutzen;
falls dies gewünscht ist, sollte man statt dessen die verzögerte Ersetzung
von B<FORMAT_ALL> benutzen.

.TP
.BR DIFF_FORMAT_NEW ", " DIFF_FORMAT_DELETE ", " DIFF_FORMAT_CHANGED " " (string)
Diese Variablen werden nur von B<eix-diff> benutzt.
Sie beschreiben das Format für Pakete die neu sind, entfernt wurden, oder für
die sich die höchste stabile Version geändert hat.
Siehe B<FORMATSTRING>.
Seit eix-0.13.4 expandieren diese Variablen als Vorgabe über verzögerte Ersetzung
zu den Variablen B<DIFF_FORMAT_ALL_NEW>, B<DIFF_FORMAT_ALL_DELETE> bzw. B<DIFF_FORMAT_ALL_CHANGED>.

.TP
.BR FORMAT_INSTALLATION_DATE ", " FORMAT_SHORT_INSTALLATION_DATE
Das strftime()-Format für die Ausgabe der Installationszeit (in normaler bzw. kurzer Form).

.TP
.BR FORMAT_INSTALLED_USE
Ein printf-ähnliche Format zur Ausgabe von Useflags installierter Pakete.
Wenn dieser String leer ist, ist die Ausführung etwas schneller, weil diese
Daten dann nicht gelesen werden.

.TP
.BR FORMAT_BEFORE_SET_USE ", " FORMAT_AFTER_SET_USE ", " FORMAT_BEFORE_UNSET_USE ", " FORMAT_AFTER_UNSET_USE
Diese Strings werden vor/nach gesetzten/ungesetzten USE-Flags installierter Versionen ausgegeben.

.TP
.BR FORMAT_BEFORE_USE_EXPAND_START ", " FORMAT_BEFORE_USE_EXPAND_END ", " FORMAT_AFTER_USE_EXPAND ", " FORMAT_BEFORE_IUSE_EXPAND_START ", " FORMAT_BEFORE_IUSE_EXPAND_END ", " FORMAT_AFTER_IUSE_EXPAND
Diese String werden zu Beginn/Ende bzw. nach B<USE_EXPAND>-Variablen bei B<use*>
für installierte bzw. verfügbare Versionen ausgegeben.

.TP
.BR FORMAT_BEFORE_COLL_EXPAND_START ", " FORMAT_BEFORE_COLL_EXPAND_END ", " FORMAT_AFTER_COLL_EXPAND
Diese String werden zu Beginn/Ende bzw. nach B<USE_EXPAND>-Variablen bei B<colliuse*> ausgegeben.

.TP
.BR FORMAT_MASKREASONS_LINESKIP ", " FORMAT_MASKREASONS_SEP ", "  FORMAT_MASKREASONSS_LINESKIP ", " FORMAT_MASKREASONSS_SEP
Diese String werden als Trenner für neue Zeilen bzw. neue Gründe bei <maskreasons> bzw. <maskreasons*> ausgegeben.

.TP
.BR COLOR_OVERLAYKEY ", " COLOR_VIRTUALKEY ", " COLOR_KEYEND ", " COLOR_OVERLAYNAME ", " COLOR_OVERLAYNAMEEND ", " COLOR_NUMBERTEXT ", " COLOR_NUMBERTEXTEND
Diese Farben werden vor/nach normalen/virtualen Overlaynummern benutzt,
zur Ausgabe der Overlays am Ende bzw. zur Ausgabe der Anzahl der Pakete.

.TP
.BR NOCOLORS " " (true / false)
Keine Benutzung von Farbsequenzen.

.TP
.BR NOSTATUSLINE " " (true / false)
Kein Update der Statuszeile.

.TP
.BR NOPERCENTAGE " " (true / false)
Keine Prozent-Fortschrittsanzeige.

.TP
.BR FORCE_COLORS " " (true / false)
Benutzung von Farbsequenzen, selbst wenn stdout kein Terminal ist.

.TP
.BR FORCE_STATUSLINE " " (true / false)
Update der Statuszeile, selbst wenn stdout kein passendes Terminal ist.

.TP
.BR FORCE_PERCENTAGE " " (true / false)
Ausgabe der Prozent-Fortschrittsanzeige, selbst wenn stdout kein Terminal ist.

.TP
.BR STYLE_VERSION_SORTED " " (true / false)
Legt fest, ob B<--versionsort> als Vorgabe aktiv ist.

.TP
.BR STYLE_VERSION_LINES " " (true / false)
Legt fest, ob B<--versionlines> als Vorgabe aktiv ist.

.TP
.BR DUP_PACKAGES_ONLY_OVERLAYS " " (true / false)
Legt fest, ob doppelte Pakete nur unter den Overlays geschehen so, d.h. ob ein
Paket wird nur dann als doppelt betrachtet wird, wenn es in mindestens zwei
verschiedenen Overlays vorkommt.

.TP
.BR DUP_VERSIONS_ONLY_OVERLAYS " " (true / false)
Legt fest, ob doppelte Versionen nur unter den Overlays gesucht werden, d.h. ob
eine Version nur dann als doppelt betrachtet wird, wenn sie mindestens zweimal
in OVerlays vorkommt.

.TP
.BR DEFAULT_IS_OR " " (true / false)
Wenn mehrere Suchmuster-Argumente ohne logische Verbindung (-a oder -o) auftauchen,
nimmt eix implizit eine solche Verbindung an.
Wenn diese Variable gesetzt ist, nimmt eix an, dass diese Verbindung -o (oder)
ist, ansonsten -a (und).

.TP
.BR OVERLAYS_LIST " " (all / all-if-used / all-used / all-used-renumbered / no)
Wenn man viele verschiedene Overlays hat, will man oft nicht alle Overlays
am Ende aufgelistet sehen, sondern nur diejenigen, die für die Ausgabe
wirklich notwendig sind.
Hier kann dieses Verhalten eingestellt werden.
Der Wert wird folgendermaßen interpretiert:

.RS
.TP
.BR all-if-used / if-used / if
Listet alle Overlays, wenn zumindest einer benutzt wurde.
Dies war des Standardverhalten vor eix-0.6.0.
.TP
.BR used-renumbered / renumber / renumbered / number
Listet nur die Overlay, die tatsächlich benutzt wurden, wobei die
Overlays in"Fussnotenreihenfolge" nummeriert werden
(d.h. wenn nur zwei Overlays benutzt werden, werden sie mit [1] und [2] nummeriert).
Der Nachteil dieses Vorgehens ist, dass Overlays für verschiedene Ausgaben
verschiedene Nummern erhalten.
Dennoch ist die Reihenfolge der Nummerierung konsistent.
.TP
.BR all-used / only-used / used
Listet nur die Overlays, die tatsächlich benutzt werden,
hält aber die Nummerierungsreihenfolgen über alle Aufrufe hinweg konsistent
(solange die Datenbank nicht geändert wird).
.TP
.BR no / false
Unterdrückt die Ausgabe der Overlays am Schluss.
.TP
alles andere
Gibt alle Overlays bei jeder Anfrage aus (selbst wenn kein einziger benutzt wurde).
.RE

.TP
.BR TERM " " (string)
Das aktuelle Terminal.
Der Wert ist typischerweise durch die Environment gesetzt.

.TP
.BR TERM_STATUSLINE " " (string)
Dies ist eine Liste von Worten (durch Leerzeichen getrennt);
falls eines dieser Worte mit dem Anfang von TERM übereinstimmt,
wird angenommen, dass das Terminal über eine Statuszeile verfügt.

.TP
.BR TERM_SOFTSTATUSLINE " " (string)
Dies ist eine Liste von Worten (durch Leerzeichen getrennt);
falls eines dieser Worte mit dem Anfang von TERM übereinstimmt,
und falls die Statuszeile aktiv ist, so wird ebenfalls eine Soft-Statuszeile
ausgegeben; diese wird beispielsweise von screen aber nicht von tmux benutzt.

.TP
.BR EXIT_STATUSLINE " " (string)
Falls dieser String nichtleer ist, wird er als Ende-Statuszeile benutzt.
Ein optionales führendes Leerzeichen in diesem String wird ignoriert.

.TP
.BR TERM_ALT1 ", " TERM_ALT2 ", " TERM_ALT3 " " "(Stringliste)"
Dies ist eine Liste regulärer Ausdrücke.
Falls einer von ihnen auf B<TERM> passt, wird B<COLORSCHEME1>, B<COLORSCHEME2>
bzw. B<COLORSCHEME3> statt B<COLORSCHEME0> benutzt,
wobei die größte passende Zahl Vorrang hat.

Natürlich steht es Ihnen frei, andere Bedeutungen zuzuweisen, aber die Absicht der
Vorgaben ist, dass ein Nicht-passendes Terminal 8/16 Farben hat, B<TERM_ALT1> die 256-farbigen
Terminals spezifiziert, B<TERM_ALT2> die 88-farbigen Terminals, und B<TERM_ALT3> für den
Benutzer frei bleibt (so dass damit alles andere überschrieben werden kann).

Die Vorgabeersetzung von B<TERM_ALT1> und B<TERM_ALT2> berücksichtigt
B<TERM_ALT1_ADD> bzw. B<TERM_ALT2_ADD> durch verzögerte Ersetzung.
Insbesondere können Sie eine Erweiterung der Vorgabewerte dadurch erreichen,
dass Sie B<TERM_ALT?_ADD> entsprechend definieren.

B<BEISPIEL 1:> Falls auf allen Terminals 8/16 Farben erzwungen werden sollen, können
Sie B<TERM_ALT3=.> setzen um für alle Terminals die B<COLORSCHEME3>-Vorgabe
zu wählen (der B<COLORSCHEME0> ist, s. unten).
Benutzer von Ethan Schoonovers B<solarized> Farbschema sollten dies nur dann tun,
wenn Sie das original 16-farbige Farbscheme von Solarized erzwingen wollen.
In jedem Fall hat hat das Setzen von B<SOLARIZED> (getrennt beschrieben) Auswirkungen.

B<BEISPIEL 2:> Wenn Sie eix mitteilen wollen, dass TERM=rxvt ein 256-Farben Terminal ist,
setzen Sie B<TERM_ALT1_ADD=rxvt>.
(Dies ist nicht mehr die Standardeinstellung, weil es rxvt-Versionen gibt, die nur 88 Farben unterstützen
und TERM=rxvt setzen; daher würde es kaputte Farben geben, wenn 256 Farben angenommen würden).
.TP
.BR SOLARIZED " " (true / light / dark / false)
Diese Variable wird nur bei verzögerter Ersetzung in den Vorgabewerten der B<COLORSCHEME?>-Variablen benutzt:
Wenn B<SOLARIZED> gesetzt ist (B<true>, B<light>, und B<dark> sind für eix derzeit äquivalent),
wählt diese Vorgabe ein Farbschema, das annimmt, dass
der Terminaloutput Ethan Schoonovers Solarized Farbscheme benutzt (helles oder dunkles Schema).
Es gibt sogar ein Solarized-Farbschema für 256 Farben: Wenn das Terminal es unterstützt,
werden neben den 16 Farben von Solarized noch weitere benutzt.
Dies entspricht nicht ganz Ethan Schoonovers ursprünglicher Philosophie bzgl. Solarized,
aber eix transportiert so viel Information über die Farben, dass diese Erweiterung angemessen erscheint.
Es wird versucht, die zusätzlichen Farben möglichst zurückhaltend einzusetzen,
z.B. möglichst nur für einzelne Symbole/Flags zu benutzen.
.TP
.BR COLORSCHEME0 ", " COLORSCHEME1 ", " COLORSCHEME2 ", " COLORSCHEME3 " " "(Integer-Liste)"
Welche dieser Variablen tasächlich benutzt wird hängt davon ab, welches B<TERM_ALT?> auf B<TERM> passt.

Der Zahlwert dieser Variablen gibt das benutzte Farbschema an;
falls die Variable zwei Zahlwerte enthält (durch Leerzeichen getrennt), wird der erste bzw. zweite Wert benutzt,
je nachdem ob der Dunkelmodus an oder aus ist (siehe B<DARK> und B<TERM_DARK>).

Der Wert 0 bedeutet, dass der erste I<COLORSTRING> von Farbspezifikationen benutzt wird;
für höhere Zahlen wird ein entsprechend späterer I<COLORSTRING> benutzt.
Falls die Zahl zu hoch ist, wird der erste I<COLORSTRING> benutzt.

Die Vorgabewerte der B<COLORSCHEME?>-Variablen berücksichtigen den Wert der Variablen B<SOLARIZED>:
Wenn B<SOLARIZED> gesetzt ist, dann wird als Vorgabe ein Farbschema benutzt, das auf
Ethan Schoonovers Solarized Systemfarben besiert (helles und dunkles Scheme werden beide unterstützt;
in 256-farbigen Terminal werden zusätzliche Farben benutzt).
Beachten Sie, dass dies nur dann eine vernünftige Ausgabe erzeugt,
wenn das Terminal konfiguriert ist, die Solarized Systemfarben zu benutzen.

Die Zahlen für die Standardeinstellungen sind:

0: Dunkles Basisschema (für schwarzen Hintergrund)

1: Dunkles Schema für 256 Farben

2: Helles Basisschema (für weißen Hintergrund)

3: Helles Schema für 256 Farben

4: Solarized (light oder dark), erweitert für 256 Farben

5: Solarized original (16 Farben, light oder dark)

Die Variablen B<BG0>, B<BG1>, B<BG2>, B<BG3> werden von den Vorgaben zur
verzögerten Ersetzung berücksichtigt, um die Hintergrundfarbe der entsprechenden Schemata zu erzwingen.
Die Vorgabe der B<BG?>-Variablen ist "none": Keine Hintegrundfarbe soll erzwungen werden.
Um die korrekten Hintergrundfarben zu erzwingen, setzen Sie die Variablen wie folgt:

B<BG0=black>

B<BG1=black>

B<BG2=white>

B<BG3=white>

(Je nach eix-Version sind einige davon sogar die Standardeinstellung).
Dies kann jedoch unerwünschte Effekte auf transparenten Terminals haben oder falls Scrollen notwendig ist, siehe den Abschnitt B<FEHLER>.
Für diese Nebeneffekte kann es - je nach Geschmack und Terminal - nützlich/hinderlich sein, B<RESET_ALL_LINES=false> oder B<RESET_ALL_LINES=true> zu setzen
(die Vorgabe kann von der eix-Version abhängen).

Die Standardwerte der  B<COLORSCHEME?>-Variablen sind:

B<COLORSCHEME0>: 0 2; dies ist für Terminals mit 8/16 Farben gedacht.

B<COLORSCHEME1>: 1 3; dies ist für 256-farbige Terminals gedacht.

B<COLORSCHEME2>: wie B<COLORSCHEME0>, für 88-farbige Terminals gedacht.

B<COLORSCHEME3>: wie B<COLORSCHEME0>, gedacht als vernünftiger Vorgabewert für Änderungen durch den Benutzer.

.TP
.BR DARK " " (true / false / auto)
Der Wert dieser Variablen gibt an, ob der Dunkelmodus bei der Wahl des Farbschemas in den B<COLORSCHEME?>-Variablen an oder aus ist.
Für den Wert B<auto> hängt das Ergebnis von einer Heuristik ab, die durch die Variablen B<TERM_DARK> und B<COLORFGBG_DARK> spezifiziert wird, siehe unten.

.TP
.B TERM_DARK " " "(Stringliste)"
Dies ist eine Liste von Paaren der Form I<regulärer Ausdruck 1> I<Dunkelmodus 1> I<regulärer Ausdruck 2> I<Dunkelmodus 2> ... wobei I<Dunkelmodus> jeweils einer der Werte B<true>, B<false>, B<true*>, B<false*> sein muss;
optional kann ein Vorgabewert für I<Dunkelmodus> als letzter Eintrag spezifiziert werden (wenn keiner spezifiziert ist, ist B<true*> die Vorgabe).
Wenn B<DARK=auto> ist, wird diese Liste benutzt, um den Dunkelmodus wie folgt festzulegen:

Der erste B<reguläre Ausdruck> wird betrachtet, der auf B<TERM> passt, und der entsprechende I<Dunkelmodus> beschreibt, was zu tun ist
(wenn kein B<regulärer Ausdruck> passt, wird angenommen, dass der I<Dunkelmodus> B<true> ist):
Die Werte B<true> (oder B<true*>) und B<false> (oder B<false*>) bedeuten, dass der Dunkelmodus an bzw. aus ist.
Für die Werte B<true> und B<false> wird aber zusätzlich die Variable B<COLORFGBG> berücksichtigt:
Wenn B<COLORFGBG> nichtleer ist, so ist der Dunkelmodus an oder aus, je nachdem ob B<COLORFGBG> auf einen Ausdruck aus B<COLORFGBG_DARK> passt.
Beachten Sie, dass B<COLORFGBG> eine Environment-Variable ist, die von einigen Terminals wie B<rxvt> oder B<konsole> gesetzt wird, um die Hintergrundfarbe zu beschreiben.

.TP
.B COLORFGBG_DARK " " "(Stringliste)"
Dies ist eine Liste regulärer Ausdrücke.
Sie wird nur benutzt, falls B<DARK=auto> ist, der entsprechende I<Dunkelmodus> in B<DARK_MODE> den Wert B<true> oder B<false> hat,
und wenn B<COLORFGBG> nichtleer ist.
Wenn all dies zutrifft, ist der Dunkelmodus an oder aus, je nachdem of B<COLORFGBG> auf einen der regulären Ausdrücke aus B<COLORFGBG_DARK> passt.
Beachten Sie, dass B<COLORFGBG> eine Environment-Variable ist, die von einigen Terminals wie B<rxvt> oder B<konsole> gesetzt wird, um die Hintergrundfarbe zu beschreiben.

.TP
.BR LEVENSHTEIN_DISTANCE " " (integer)
Legt die Vorgabe für den Levenshtein-Abstand fest.

.TP
.BR UPDATE_VERBOSE " " (true / false)
Legt fest, ob eix-update -v als Vorgabe an ist
(Ausgabe der effektiven Cachemethode pro Version).

.TP
.BR EXCLUDE_OVERLAY " " "(Stringliste)"
Eine Liste von Wildcard Patterns für Overlay-Pfade, die von der Indizierung ausgeschlossen werden.
Siehe die B<eix-update>-Option B<--exclude-overlay>.

.TP
.BR ADD_OVERLAY " " "(Stringliste)"
Eine Liste von Overlays, die zur Indizierung hinzugefügt werden.
Siehe die B<eix-update>-Option B<--add-overlay>.

.TP
.BR EXPORT_PORTDIR_OVERLAY " " (true / false)
Falls dies gesetzt ist und Overlays hinzugefügt/entfernt wurden, wird
eine entsprechend modifierte B<PORTDIR_OVERLAY>-Variable exportiert.
Dies bedeutet, dass in gewissem Sinne auch die entsprechenden eclasses
dieser Overlays für die Cachemethoden eix und eix* hinzugefügt/entfernt werden.

.TP
.BR CACHE_METHOD_PARSE " " (string)
Dieser String wird an alle Cachemethoden angehängt, die parse/parse*/ebuild/ebuild* benutzen.
Die Vorgabe enthält B<#metadata-md5#metadata-flat>.
Außer für spezielle Situationen ist dies meist erwünscht:
Es bedeutet, dass wenn aktuelle Metadaten (in einem metadata/*cache Unterverzeichnis)
verfügbar sind, so werden diese anstelle des Parsens/Ausführens des ebuilds benutzt.

Letzteres ist prinzipiell nicht verlässlich (Parsen) oder ziemlich langsam (Ausführen),
d.h. die Metadaten (falls vorhanden und aktuell) sind immer vorzuziehen.
Näheres dazu findet sich im Abschnitt B<BESCHLEUNIGUNG>.

.TP
.BR PORTDIR_CACHE_METHOD ", " OVERLAY_CACHE_METHOD " " (string)
Legt den Cachetyp für Portage und Overlays fest.
Die Vorgabe für B<PORTDIR_CACHE_METHOD> ist I<@PORTDIR_CACHE_METHOD@>,
die für B<OVERLAY_CACHE_METHOD> ist I<parse|ebuild*>.

Aus Geschwindigkeitsgründen sind auch für Overlays grundsätzlich Metadaten vorzuziehen.
Näheres dazu findet sich im Abschnitt B<BESCHLEUNIGUNG>.

B<Sicherheitswarnung:>
Falls die .ebuilds der Overlays nicht vollständig vertrauenswürdig sind,
sollte man B<OVERLAY_CACHE_METHOD=parse> benutzen.

Man kann auch temporär B<OVERLAY_CACHE_METHOD=eix*::~> setzen:
Wie später erklärt, wird eix dann als Vorgabe die Overlay-Daten aus der
vorherigen eix Datenbank nehmen.

Die möglichen Cachemethoden werden weiter unten beschrieben.
Es ist möglich, für bestimmte Overlays andere Cachemethoden zu wählen.
Dies kann über die folgenden Variablen geschehen:

.TP
.BR CACHE_METHOD ", " OVERRIDE_CACHE_METHOD " " "(Stringliste)"
Diese Variablen sind Stringlisten der Gestalt "I<Overlay> I<Methode> I<Overlay> I<Methode> ...".
Die Cachmethode eines jeden I<Overlay> wird auf die darauffolgende I<Methode> gesetzt;
dies überschreibt also die Vorgabe von B<OVERLAY_CACHE_METHOD>,
(oder von B<PORTDIR_CACHE_METHOD> falls I<Overlay> das B<PORTDIR>-Verzeichnis ist).
I<Overlay> wird als ein Wildcard-Muster interpretiert, das auf den I<Pfad>
(mit aufgelösten symbolischen Links) des Overlays passen sollte.
(Es ist nicht möglich, hier den Repositorynamen anzugeben - es muss der
aufgelöste I<Pfad> benutzt werden).
Spätere Einträge überschreiben frühere: Der letzte passende Eintrag gewinnt.

.RS
Der Unterschied zwischen B<CACHE_METHOD> und B<OVERRIDE_CACHE_METHOD> besteht darin,
dass das erste sofort angewandt wird, während das letzte auch benutzt werden kann,
um Änderungen zu überschreiben/erweitern, die implizit gemacht werden, wenn B<KEEP_VIRTUALS>
gesetzt ist (siehe unten).

Die Standarddefinitionen von B<CACHE_METHOD> und B<OVERRIDE_CACHE_METHOD>
enthalten B<%{ADD_CACHE_METHOD}> bzw. B<%{ADD_OVERRIDE_CACHE_METHOD}>.
Durch verspätete Ersetzung, die in einem anderen Abschnitt erklärt wird,
bewirkt dies, dass die Variables B<ADD_CACHE_METHOD> bzw.
B<ADD_OVERRIDE_CACHE_METHOD> ebenfalls benutzt werden können, um die
Cachemethoden lokal zu überschreiben.
Falls Sie B<CACHE_METHOD> oder B<OVERRIDE_CACHE_METHOD> in I<@SYSCONFDIR@/eixrc>
verändern, ist die Empfehlung zusätzlich " B<%{ADD_CACHE_METHOD}>" bzw.
" B<%{ADD_OVERRIDE_CACHE_METHOD}>" (beachte das Leerzeichen vor B<%>)
an das Ende der neuen Definitionen anzufügen, so dass diese Variablen nach wie
vor ein lokales Überschreiben erlauben.

Die folgenden Cachemethoden werden unterstützt:

.TP
.BR metadata-flat " oder " metadata-flat:I<PFAD>
Benutzt den Metadatencache innerhalb des Portagebaums ($PORTDIR/metadata/cache).
.RS
Falls I<PFAD> angegeben ist, überschreibt dies den obigen Pfad;
in diesem Fall muss der volle Pfad angegeben werden (d.h. es wird kein Präfix automatisch vorgestellt).
Die Angabe von I<PFAD> kann für Paketmanager nötig sein, die die Metadaten in einem anderen Verzeichnis generieren.
.RE
.TP
.BR metadata-md5 " oder " metadata-md5:I<PFAD>
Dies ähnlich wie B<metadata-flat> mit dem Unterschied, dass die Dateien aus
($PORTDIR/metadata/md5-cache) benutzt werden, die eine MD5-Prüfsumme statt
des Zeitstempels zur Prüfung auf Aktualität erlauben.
Dies sollte die bevorzugt Methode für Overlays sein, wenn es vom Overlay
unterstützt wird, d.h. wenn die B<metadata/layout.conf>-Datei die Zeile
B<cache-format=md5-dict> enthält.
(Beachte, dass nur Portage die Datei B<metadata/layout.conf> liest;
eix tut dies nicht).
.TP
.BR metadata-assign " oder " metadata-assign:I<PFAD>
Dies ist ähnlich zu B<metadata-flat> mit dem Unterschied, dass die Dateien
im Metadatencache im "assignment format" (TYP=Wert) erwartet werden,
was für einige alt-gentoo-Bäume der Fall ist.
.TP
.BR metadata-md5-or-flat ", " metadata-md5-or-flat:I<PFAD>
Dies ist ähnlich zu B<metadata-flat> mit dem Unterschied, das für jede
Kategorie zunächst ein entsprechendes Verzeichnis in $PORTDIR/metadata/md5-cache
gesucht wird.
Falls der I<PFAD> angegeben ist, ist diese Methode äquivalent zu B<metadata-md5>:I<PFAD>.
.TP
.BR metadata-md5-or-assign ", " metadata-md5-or-assign:I<PFAD>
Dies ist ähnlich zu B<metadata-assign> mit dem Unterschied, das für jede
Kategorie zunächst ein entsprechendes Verzeichnis in $PORTDIR/metadata/md5-cache
gesucht wird.
Falls der I<PFAD> angegeben ist, ist diese Methode äquivalent zu B<metadata-md5>:I<PFAD>.
.TP
.B sqlite
Dies ist eine extrem schnelle Cachemethode, falls Portage mit dem
sqlite-Backend benutzt wird, siehe
http://wikigentoo.ksiezyc.pl/TIP_speed_up_portage_with_sqlite.htm
or
https://wiki.gentoo.org/wiki//etc/portage/modules
(ältere Links zu diesem Thema waren
I<http://gentoo-wiki.com/TIP_speed_up_portage_with_sqlite>
oder
I<http://gentoo-wiki.info/TIP_speed_up_portage_with_sqlite>
oder
I<http://en.gentoo-wiki.com/wiki/Portage_SQLite_Cache>
obwohl anscheinend keiner davon mehr erreichbar ist).

Beachten Sie, dass im Gegensatz zur Vorgabe-Cachemethode B<metadata>
zunächst B<emerge --metadata> ausgeführt werden muss, bevor
B<eix-update> diese Methode benutzen kann.

.RS
Da für diese Methode B<sqlite> installiert sein muss, ist diese
Methode möglicherweise nicht in das eix-update-Programm einkompiliert.
Dies ist nur der Fall, wenn B<eix> mit dem entsprechenden USE-flag
(oder manuell mit I<./configure --with-sqlite> vor der Kompilation)
gebaut wurde.

Wie für andere Cachemethoden auch werden nur diejenigen Kategorien
berücksichtigt, die durch profile/category (im Hauptbaum oder einem Overlay)
festgelegt werden.
Falls dies unerwünscht ist, kann man B<sqlite*> benutzen (s. unten).
.RE
.TP
.B sqlite*
Dies ist analog zur Cachemethode B<sqlite> mit dem Unterschied,
dass alle Kategorien aus der Date hinzugefügt werden, selbst diejenigen,
die nicht in einer profile/categories-Datei aufgelistet wurden.
.TP
.BR flat " oder " flat:I<PFAD>
Die ist ähnlich zu B<metadata-flat> mit dem Unterschied, dass die Metadaten
im Verzeichnis I<PFAD>I<$PORTAGE_OR_OVERLAY_DIR> erwartet werden.
Falls I<PFAD> weggelassen wird, ist seine Vorgabe B</var/cache/edb/dep>.

.RS
Diese Methode kann mit <portage-2.1 und dessen Standard-Backend benutzt werden.
.RE
.TP
.BR assign " oder " assign:I<PFAD>
Dies ist analog zu B<flat> mit dem Unterchied, dass die Dateien
im "assignment format" (TYP=Wert) erwartet werden.
Dies ist bei portage-2.1 mit dem Standard-Backend der Fall.

.RS
Wenn >=portage-2.1 mit dem Standard-Backend benutzt wird, kann dies
die Cachemethode der Wahl sein, wenn man für eix-update keinen Zugang
zum Portagebaum hat.
Beachten Sie, dass im Gegensatz zur Vorgabe-Methode B<metadata-*>
zunächst B<emerge --metadata> ausgeführt werden muss, bevor
man diese Methode mit B<eix-update> benutzen kann.
In diesem Fall wird man vermutlich eine entsprechende Option für eix-sync angeben.
.RE
.TP
.BR repo-flat " oder " repo-flat:I<PFAD> " oder " repo-assign " oder " repo-assign:I<PFAD>
Dies ist analog zu B<flat>/B<assign> mit dem Unterschied, dass die Metadaten
im Verzeichnis I<PFAD>B</>I<$repo_name> erwartet werden.
Falls I<$repo_name> leer ist, wird der Name B<x->I<XXX> angenommen, wobei I<XXX>
die letzte nichtleere Pfadkomponente des Portage/Overlay-Verzeichnisses ist.
Dies entspricht dem Namensschame aus paludis.
Falls dies für einige Overlays den falschen Pfad liefert, lässt sich dies
immer noch manuell überschreiben, z.B. mit
.BI "OVERRIDE_CACHE_METHOD='" bad_overlay " " metadata-assign ":" korrekter_pfad "'".
.TP
.BR parse "[" # Metadatenmethode "]..."
Holt die Informationen aus den ebuilds, die mit gewissen Heuristiken geparsed werden.
Dadurch hat diese Methode keine Sicherheitsrisiken, aber möglicherweise andere Probleme.
Falls Beispielsweise Variablen nur in eclass-Dateien gesetzt werden, werden sie durch
diese Methode nicht erkann.
Beispiele für Probleme mit dieser Methode sind fehlende Slot-Informationen für
typische Ebuilds aus kde-base oder unsinnige Versionsnummer für gcc cross-compiler.
Diese Methode ist die Cachemethode B<none> älterer eix-Versionen (vor 0.11.1).

.RS
Es ist optional möglich, einen oder mehrere Strings der Gestalt
B<#>I<Metadatenmethode> anzuhängen, wobei I<Metadatenmethode> irgendeine der
obigen Cachemethoden ist (mit Ausnahme von B<sqlite>).
In diesem Fall, werden die Metadatenmethoden anstelle des Ebuilds benutzt,
falls sie aktuelle Informationen liefern.
(die erste passende Metadatenmethode gewinnt).

Dies ist normalerweise das Gewünschte, vor allem für Overlays, da
Metadaten verlässlicher sind als die Ergebnisse der Cachemethode B<parse>.
Natürlich ist das nur dann nützlich, wenn der Overlay I<foo> Metadaten
enthält, die vom Overlay-Maintainer regelmäßig mit

.B egencache --repo=I<foo> --update

auf den neuesten Stand gebracht werden.
(Ob dies für layman-Overlays geschieht, hängt vom jeweiligen Overlay-Maintainer ab;
für lokale Overlays kann man natürlich das obige Kommando manuell ausführen).

Da dies normalerweise das Gewünschte ist, wird der String aus B<CACHE_METHOD_PARSE>
als Vorgabe an die Cachemethode B<parse> angehängt.

Falls man natürlich im voraus weiß, dass die Metadaten des Overlays aktuell sind,
ist es (etwas) shcneller, direkt die entsprechende Metadatenmethode (meist B<metadata-flat>)
zu benutzen.
Letztere ist sinnvoll, falls beispielsweise B<egencache> von einem Script ausgeührt
wird, das zum Syncen von Overlays benutzt wird (etwa von eix-sync).
.RE
.TP
.BR parse* "[" # "Metadatenmethode]..."
Dies ist i.W. dasselbe wie die Cachemethode B<parse> mit dem Unterschied,
dass die Variablen in Variablendefinitionen nicht expandiert werden.
Dies ist die Cachemethode B<none*> älterer eix-versionen (vor 0.11.1)
und die Cachemethode B<none> sehr alter eix-Versionen (vor 0.7.1)
.TP
.BR ebuild "[" # "Metadatenmethode]..."
Falls kein Portage-Cache verfügbar ist (etwa für Overlays),
ist dies die kompatibelste aber auch langsamste Methode.
Die Information wird über "/usr/bin/ebuild ... depend" aus dem ebuild gewonnen.
Da dabei die ebuilds von bash ausgeführt werden, kann dies ein
Sicherheitsrisiko sein, falls man den ".ebuild"-Skripten oder den
Environmentvariablen nicht vertrauen kann.
Die Environment wird vor dem Ausführen bewusst nicht gelöscht, so dass
weitere Variablen an das Ebuild übergeben werden können.
Dies kann jedoch auch zu unerwartetem Verhalten oder gar zu einem
Sicherheitsrisiko führen, da Bash-Skripte durch getürkte Environments
oft irregeleitet werden können.
Um solche Probleme zu vermeiden, kann man etwa B<env -i eix-update> benutzen.

.RS
.B Benutzen Sie diese Methode nicht, wenn Sie nicht allen .ebuilds vertrauen, auf die diese Methode angewendet werden soll!

Die optionalen Anhänge B<#>I<Metadatenmethode> wurden schon bei der Cachemethode B<parse> beschrieben.
Beachten Sie, dass wenn die entsprechenden Metadaten vorhanden sind, dies wesentlich schneller ist, als das ebuild auszuführen.
.RE
.TP
.BR ebuild* "[" # "Metadatenmethode]..."
Dies ist eine etwas schnellere und dafür etwas weniger kompatible Variante von B<ebuild>:
Die Information wird über das undokumentierte Programm "/usr/lib/portage/ebuild.sh" gewonnen.
Statt also wie bei der Cachemethode  B<ebuild> ein Python-Programm für jedes ".ebuild" auszuführen,
wird "nur" ein längliches Shellskript und das ebuild selbst ausgeführt
(folglich ist auch diese Methode unsicher, falls man nicht allen ".ebuild"-Skripten vertrauen kann).
Die meisten Environmentvariablen außer Portage-spezifischen Variablen und PATH werden gelöscht;
PORTAGE_ROOTPATH wird exportiert;
einige .ebuild-spezifische Variables wie $P werden gesetzt, wenn das Ebuild ausgeführt wird.
Diese Methode ist nicht ganz so kompatibel wie B<ebuild>, und es kann von der Portage-Version abhängen,
ob sie überhaupt möglich ist.
Aber sie ist dennoch deutlich schneller als B<ebuild>, und stabil genug um beispielsweise
typische Ebuilds aus kde-base korrekt zu handhaben.

.RS
.B Benutzen Sie diese Methode nicht, wenn Sie nicht allen .ebuilds vertrauen, auf die diese Methode angewendet werden soll!
.RE
.TP
.BR parse|ebuild ", " parse*|ebuild ", " parse|ebuild* ", " parse*|ebuild*  " [" # "Metadatenmethode]..."
Dies ist eine Mischung aus B<parse>/B<parse*> und B<ebuild>/B<ebuild*>:
Jedes Ebuild wird zunächst mit der Methode B<parse>/B<parse*> untersucht.
Wenn im Ergebnis offensichtlich Informationen fehlen oder merkwürdig erscheinen,
wird das Ebuild der Cachemethode B<ebuild>/B<ebuild*> unterzogen.
Als Faustregel ist diese Methode wesentlich schneller als B<ebuild>/B<ebuild*>
aber immer noch wesentlich langsamer als B<parse>/B<parse*>.
Natürlich hat sie die selben sicherheitsprobleme wie B<ebuild>/B<ebuild*>.

.RS
.B Benutzen Sie diese Methode nicht, wenn Sie nicht allen .ebuilds vertrauen, auf die diese Methode angewendet werden soll!
.RE
.TP
.BR eix "  oder   "  eix:I<DATEI> "  oder  " eix:I<DATEI>:I<Overlay>
Benutzt die Cachedatei I<DATEI>, die durch einen frühren Aufruf von B<eix-update> erzeugt wurde.
Falls I<DATEI> leer ist oder weggelassen wird, ist die Vorgabe @EIX_CACHEFILE@.

.RS
Wie für andere Cachemethoden auch werden nur diejenigen Kategorien
berücksichtigt, die durch profile/category (im Hauptbaum oder einem Overlay)
festgelegt werden.
Falls dies unerwünscht ist, kann man B<eix*> benutzen (s. unten).

Falls I<Overlay> nicht angegeben wurde oder leer ist, wird nur
der "Hauptbaum" aus I<DATEI> gelesen - Overlays innerhalb I<DATEI> werden ignoriert.
Andernfalls wird nur der zum I<Overlay> zugehörige Teil aus I<DATEI> gelesen.
Hierbei bedeutet "zugehöriger Teil" den ersten Overlay aus I<DATEI>, der auf das Wildcard-Muster I<Overlay> passt.
"Passen" wiederum bedeutet, dass zunächst das Label getestet wird, dann der Pfad und schließlich die
Nummer des Overlays innerhalb I<DATEI>.
Beachte, dass I<Overlay> i.a. nicht in Verbindung mit aktuellen Overlaynamen oder -nummern stehen muss:
Nur die in I<DATEI> gespeicherten Namen/Nummern sind hier entscheidend.

Es gibt zwei Ausnahmewerte für I<Overlay>, die nach anderen Regeln behandelt werden:

Falls I<Overlay> den speziellen Wert "~" hat, so wird der Names des aktuellen Overlaylabels implizit als I<Overlay>-Argument benutzt;
falls das aktuelle Overlaylabel leer ist oder nicht passt, wird statt dessen der aktuelle Overlaypfad benutzt.

Falls I<Overlay> den speziellen Wert "*" hat, so werden B<all> Overlays aus I<DATEI> gelesen.
Beachten Sie, dass dies normalerweise nicht das Gewünschte ist, weil es bedeutet,
dass falls I<DATEI> ursprünglich mehrere Overlays enthielt, wird diese Overlay-Struktur "eingeflacht".
.RE
.TP
.BR eix* "  oder   "  eix*:I<DATEI> "  oder  " eix*:I<DATEI>:I<Overlay>
Dies ist analog zur Cachemethode B<eix> mit dem Unterschied, dass
alle Kategorien aus I<DATEI> hinzugefügt werden, auch jene, die
nicht in einer profile/categories-Datei gelistet wurden.

.RS
Diese cachemethode ist nützlich, falls I<DATEI> Informationen über ein
Overlay-Verzeichnis enthält, dessen entsprechendes profile/categories-Datei
auf dem lokalen Rechner unbekannt oder nicht notwendigerweise aktuell ist.

Dies wird für B<eix-remote> benutzt.

Beachten Sie insbesondere, dass mit B<PORTDIR_CACHE_METHOD=eix*::~>
die Overlaydaten als Vorgabe einfach von der vorherigen eix-Cachedatei
"kopiert" werden.
.RE
.RE

.TP
.BR KEEP_VIRTUALS " " (true / false)
Falls diese Variable gesetzt ist, wird eix-update alle virtuellen Overlays
aus dem vorhergehenden Cachefile (falls es ein solches gibt) übernehmen.

Dies hat den selben Effekt als wenn man für jeden virtuellen Overlay
der alten Datenbank den Eintrag "I<Overlayname>" zu B<ADD_OVERLAY>
hinzufügt und einen entsprechenden Eintrag "I<Overlay> eix*::I<Overlay>" zu
B<CACHE_METHOD>.
Dies bedeutet, dass diese Option ggf. Angaben aus B<CACHE_METHOD> überschreibt.
Die Änderungen können allerdings wieder durch B<OVERRIDE_CACHE_METHOD>
überschrieben werden.
.TP
.BR REPO_NAMES
Diese Variable ist eine Stringliste der Gastalt "I<Verzeichnismuster> I<Overlaylabel> I<Verzeichnismuster> I<Overlaylabel> ...".
Bei der Erzeugung einer neuen Datenbank erhält der Overlay, der auf I<Verzeichnismuster> passt
das Label I<Overlay-label>, unabhängig vom Inhalt seiner profiles/repo_name Datei.
Diese Variable kann auch virtuellen Overlays, die naturgemäß keine solche Datei haben können, Labelnamen zuordnen.
Insbesondere kann diese Variable auch Overlaylabel überschreiben, die durch KEEP_VIRTUALS gesetzt werden.
Spätere Einträge überschreiben frühere: Der letzte passende Eintrag gewinnt.
.TP
.BR LOCAL_PORTAGE_CONFIG " " (true / false)
Falls nicht gesetzt, werden /etc/portage und B<ACCEPT_KEYWORDS> (aus make.conf bzw. der Environment) ignoriert.
Seit eix-0.7.9 wird empfohlen, den Wert dieser Variable auf dem Vorgabewert "true" zu belassen,
weil durch das Setzen auf "false" nur Informationen vor dem Benutzer versteckt werden.
.TP
.BR ALWAYS_ACCEPT_KEYWORDS " " (true / false)
Entscheidet, ob B<ACCEPT_KEYWORDS> selbst ohne B<LOCAL_PORTAGE_CONFIG> benutzt wird,
etwa um die "Standard"-Stabilität zu berechnen.
.TP
.BR UPGRADE_LOCAL_MODE " " (+ " oder " local / - " oder " non-local "/etwas anderes" )
Falls diese Variable B<+> / B<-> ist, wird sich die B<--upgrade>-Option von eix
so verhalten, als wenn B<LOCAL_PORTAGE_CONFIG> auf B<true> / B<false> gesetzt wäre.
.TP
.BR RECOMMEND_LOCAL_MODE " " (+ "  oder " local / - " oder " non-local "/etwas anderes" )
Falls diese Variable B<+> / B<-> ist, werden sich upgrade/downgrade-Empfehlungen
sowie in eix-diff die Tests auf Versionsänderungen so verhalten, als wenn
B<LOCAL_PORTAGE_CONFIG> auf B<true> / B<false> gesetzt wäre.
.TP
.BR UPGRADE_TO_HIGHEST_SLOT " " (true / false)
Entscheidet, ob Upgrade-Tests ein positives Ergebnis liefern, falls für ein
installiertes Paket nicht der Slot mit der höchsten stabilen Version installiert ist.
Ausnahmen dieser allgemeinen Politik können in
B</etc/portage/package.slot_upgrade_forbid> bzw.
B</etc/portage/package.slot_upgrade_allow> angegeben werden.
.TP
.BR RECURSIVE_SETS " " (true / false)
Entscheidet of Sets und Pakete eines inkludierten Sets als Teil des Eltern-Sets verstanden werden sollen.
.TP
.BR XML_KEYWORDS (full / effective / both / true / full* / effective* / none / false)
Entscheidet bei --xml, ob die vollen/effektiven (oder beide) Typen von B<KEYWORDS> für jede Version ausgegeben werden.
Hier heißt "voll" der B<KEYWORDS>-String des Ebuild und "effectiv" seine eventuelle Modifikation durch das Profil.
Die Werte B<full*>/B<effective*> sind ähnlich B<full>/B<effective>, aber beide Typen werden ausgegeben,
wenn sich ihre Werte unterscheiden.
B<true>/B<false> ist gleichbedeutend mit B<full*>/B<none>.
.TP
.BR XML_OVERLAY " " (true / false)
Entscheidet bei --xml, ob der Overlay (d.h. sein Pfad) für jede Version ausgegeben werden soll.
Für Versionen aus Overlays ohne Label (Repositorynamen) hat dies keinen Einfluss:
Für solche Version wird grundsätzlich der Overlay ausgegeben.
.TP
.BR SORT_INST_USE_ALPHA " " (true / false)
Bei B<true> werden die USE-Flags installierter Pakete in alphabetischer Reihenfolge ausgegeben.
Andernsfalls werden (in alphabetischer Reihenfolge) zunächst diejenigen ausgegeben, die
beim Emerge des Pakets gesetzt waren und dann die restlichen
(ebenfalls in alphabetischer Reihenfolge).
.TP
.BR CHECK_INSTALLED_OVERLAYS " " (true / false / repository)
Bei B<true> wird grundsätzlich überprüft, von welchem Overlay ein Paket installiert wurde.
Bei B<false> wird das nur für diejenigen Pakete überprüft,
die in mindestens zwei Bäumen verfügbare Versionen haben,
d.h. nur für Pakete, bei denen es anhand der Datenbank vernünftig erscheint,
dass es von einem anderen Overlay installiert sein könnte.
Diese Information könnte natürlich falsch sein, falls das Paket nach der
Installation aus dem Overlay entfernt wurde, oder falls sich der gesamte
Overlay nicht mehr in der Datenbank befindet.

Der spezielle Wert B<repository> ist ein vernünftiger Kompromiss:
Falls Repository-Daten beim Emerge gespeichert wurden (was nur bei aktuelleren
Portage-Verseionen der Fall ist; mit B<eix-installed [no-]repository> lässt
sich überprüfen, für welche Versionen das (nicht) der Fall ist),
dann werden diese Repository-Daten grundsätzlich benutzt.
Nur wenn sie fehlen, ist das Verhalten für die entsprechende Version
wie im Falle B<CHECK_INSTALLED_OVERLAYS=false>.

Vor allem im Zusammenhang mit der Option -T (falls
B<NONEXISTENT_IF_OTHER_OVERLAY> gesetzt ist) und mit der Option -J
ist der Geschwindigkeitszuwachs enorm, wenn diese Variable auf
B<false> oder B<repository> gesetzt ist, aber man sollte sich bewussst sin,
dass die erhaltene Information über installierte Overlays dann nicht
vollkommen verlässlich ist (für mit älteren Portage-Versionen installierte Pakete).
Insbesondere wird die Option -T nicht feststellen, falls eine installierte
Version eines Pakets tatsächlich aus einem redundanten Overlay stammt,
falls in der aktuellen Datenbank alle Version des Paket von einem
einzigen (anderen) Repository kommen.
.TP
.BR PRINT_COUNT_ALWAYS " " (true / false / never)
Bei B<true> wird stets die Trefferzahl in der letzten Zeile ausgegeben,
selbst dann, wenn diese Zahl 0 oder 1 sein sollte.
Bei B<PRINT_COUNT_ALWAYS=never> wird diese letzte Zeile grundsätzlich unterdrückt.
Beides ist im Normalfall nicht nützlich, aber es kann für einfache Skripte
bequem sein, die die Ausgabe von eix parsen.
.TP
.BR COUNT_ONLY_PRINTED " " (true / false)
Bei B<false> wird nur die Trefferzahl der Pakete berücksichtigt,
unabhängig davon, ob diese Treffer zu irgendeiner Ausgabe geführt haben.
Dies kann für gewisse Skripte nützlich sein bei denen man nur an der
Trefferzahl interessiert ist, und für die dann zur Beschleunigung
beispielsweise B<FORMAT=''> benutzt werden kann.
.TP
.\" {{{ Default match fields and algorithms
.BR DEFAULT_MATCH_FIELD " " "(Stringliste)"
Dies ist eine Stringliste der Gestalt I<regulärer_Ausdruck>[\\n\\r\\t ]I<Operandenfeld>,
die benutzt wird, um die Vorgaben für das Operandenfeld
(gegen das das Suchmuster getestet wird) zu ermitteln.
Das Suchmuster der Kommandozeile wird dazu gegen alle Werte aus I<regulärer_Ausdruck>
der Liste (in der Reihenfolge der Liste) getestet.
Für den ersten Treffer wird das entsprechende I<Operandenfeld> als Vorgabe benutzt.
Es kann ein abschließendes I<Operandenfeld> (ohne I<regulärer_Ausdruck>) in der Liste angegeben werden,
das als Vorgabe dient, wenn es keinen anderen Treffer gab; wenn es keinen solchen
letzten Eintrag gibt, wird B<name> angenommen.
Für die Angaben von I<regulärer_Ausdruck> kann die verspätete Ersetzung vom Typ ${\\VAR}
praktisch sein, da man sich so das händische Escapen spart.

Die möglichen Werte für I<Operandenfeld> sind: B<name>, B<category>, B<category/name>
(oder B<category-name>), B<description>, B<license>, B<homepage>, B<set>, B<eapi>, B<installed-eapi>,
B<slot>, B<installed-slot>, B<use> (oder B<iuse>), B<with-use> (oder B<installed-with-use>),
B<without-use> (oder B<installed-without-use>), B<src-uri> (oder B<srcuri>),
B<deps>, B<depend>, B<rdepend>, B<pdepend>, B<bdepend>, B<idepend> und B<error>.
Sie entsprechen den analogen Kommandozeilenoptionen für die Operandenwahl.
Der spezielle Wert B<error> bedeutet, dass eix mit der Fehlermeldung abbricht,
dass das Operandenfeld nicht automatisch erkannt werden kann und explizit
angegeben werden muss.

Zum Testen von Skripten empfiehlt es sich, B<DEFAULT_MATCH_FIELD=error> zu
setzen, so dass sich Skripte nicht auf spezielle Vorgaben von
B<DEEFAULT_MATCH_FIELD> verlassen: Diese Vorgabe hat sich in der Geschichte von
eix bereits mehrfach geändert und wird es vermutlich irgendwann wieder tun.
.TP
.BR DEFAULT_MATCH_ALGORITHM " " "(Stringliste)"
Dies ist eine Stringliste der Gestalt  B<(>I<Operandenfeld_Spezifikation>B<)>I<regulärer_Ausdruck>[\\n\\r\\t ]I<Matchalgorithmus>,
die benutzt wird, um die Vorgabe für den Matchalgorithmus
(für den das Suchmuster gedacht ist) zu ermitteln.
Dies ist analog wie bei B<DEFAULT_MATCH_FIELD>, haupstächlichr mit dem Unterschied,
dass natürlich I<Matchalgorithmus> den Vorgabe-Matchalgorithmus angibt.

Die möglichen Werte für I<Matchalgorithmus> sind: B<regex>, B<regexcase>,
B<pattern>, B<substring>, B<begin>, B<end>, B<exact>, B<fuzzy>. Sie entsprechen
den analogen Kommandozeilenoptionen für die Wahl des Matchalgorithmus.
Der spezielle Wert B<error> bedeutet, dass eix mit der Fehlermeldung abbricht,
dass der Matchalgorithmus nicht automatisch erkannt werden kann und explizit
angegeben werden muss.
Falls keine andere Vorgabe für den Matchalgorithmus spezifiziert wird, wird B<regex> benutzt.

In jedem String kann einer der beiden Teile B<(>I<Operandenfeld_Spezifikation>B<)> und I<regulärer_Ausdruck> weggelassen werden.
Wird keiner weggelassen, müssen sie beide gleichzeitig passen, damit der Algorithmus selektiert wird.
Die I<Operandenfeld_Spezifikation> bezieht sich auf die effektiv selektierten Operandenfeld-Werte
gemäß der folgenden Regeln.

I<Operandenfeld_Spezifikation> ist eine Verkettung von Worten der Gestalt
B<|>I<Operandenfeld>, B<&>I<Operandenfeld> und B<!>I<Operandenfeld>,,
wobei für I<Operandenfeld> die selben Werte möglich sind wie in B<DEFAULT_MATCH_FIELD> (mit Ausnahme von B<error>).
Die Reihenfolge dieser Worte spielt keine Rolle.

eix kombiniert alle I<Operandenfeld>-Werte, die mit dem selben Zeichen beginnen
(B<|>, B<&> oder B<!>) und gewinnt dadurch 3 (möglicherweise leere) Familien von Operandenfeldern.
Die I<Operandenfeld_Spezifikation> passt, wenn die folgenden Bedingungen alle erfüllt sind:

1. Wenn die erste Familie (B<|>) nicht leer ist, so ist mindestens ein Operandenfeld dieser Familie effektiv selektiert (man denke an ein logisches "oder").

2. Mindestens all Operandenfelder der zweiten Familie (B<&>) sind effektiv selektiert (man denke an ein logisches "und").

3. Wenn die dritte Familie (B<!>) nicht leer ist, so sind höchststens Operandenfelder dieser Familie selektiert (man denke an ein logisches "nicht (... oder ... oder ...)").

Um beispielsweise anzugeben, dass genau alle der Felder B<depend>, B<rdepend>, B<pdepend>, B<bdepend>, B<idepend> selektiert sind
(also B<--deps>) und kein weiteres, kann man einen der Spezifikationen

.B (&deps!deps)

.B (&depend&rdepend&pdepend&bdepend&idepend!depend!rdepend!pdepend!bdepend!idepend)

benutzen.
Will man andererseits spezifieren, dass mindestens eines von B<depend>, B<rdepend>, B<pdepend>, B<bdepend>, B<idepend>
selektiert ist aber ansonsten nichts, kann man das wie folgt tun:

.B (|deps!deps)

.B (|depend|rdepend|pdepend|bdepend|idepend!depend!rdepend!pdepend!bdepend!idepend)

Zum Testen von Skripten empfiehlt es sich, B<DEFAULT_MATCH_ALGORITHM=error> zu
setzen, so dass sich Skripte nicht auf spezielle Vorgaben von
B<DEEFAULT_MATCH_ALGORITHM> verlassen: Diese Vorgabe hat sich in der Geschichte von
eix bereits mehrfach geändert und wird es vermutlich irgendwann wieder tun.
.TP
.\" }}}
.\" {{{ Definition of Redundancy
.BR TEST_FOR_EMPTY " " (true / false)
Legt fest, ob leere Einträge in /etc/portage/package.* bei -t angezeigt werden.
.TP
.BR TEST_KEYWORDS " " (true / false)
Legt fest, ob /etc/portage/package.{accept_,}keywords bei -t getestet wird.
.TP
.BR TEST_MASK " " (true / false)
Legt fest, ob /etc/portage/package.mask bei -t getestet wird.
.TP
.BR TEST_UNMASK " " (true / false)
Legt fest, ob /etc/portage/package.unmask bei -t getestet wird.
.TP
.BR TEST_USE " " (true / false)
Legt fest, ob /etc/portage/package.use bei -t getestet wird.
.TP
.BR TEST_ENV " " (true / false)
Legt fest, ob /etc/portage/package.env bei -t getestet wird.
.TP
.BR TEST_LICENSE " " (true / false)
Legt fest, ob /etc/portage/package.license bei -t getestet wird.
.TP
.BR TEST_RESTRICT " " (true / false)
Legt fest, ob /etc/portage/package.accept_restrict bei -t getestet wird.
.TP
.BR TEST_CFLAGS " " (true / false)
Legt fest, ob /etc/portage/package.cflags bei -t getestet wird.
.TP
.BR TEST_REMOVED " " (true / false)
Legt fest, ob gelöschte Pakete mit -t getestet werden.
.TP
.BR TEST_FOR_NONEXISTENT " " (true / false)
Legt fest, ob nicht-existente installierte Versionen bei -T positiv sind.
Die B<NONEXISTENT_IF>-Variablen legen dabei fest, was nicht-existent bedeutet.
.TP
.BR TEST_FOR_REDUNDANCY " " (true / false)
Legt fest, ob redundante Einträge in /etc/portage/package.* bei -T positiv sind.
Die B<REDUNDANT_IF>-Variablen legen dabei fest, was redundant bedeutet.
.TP
.BR ACCEPT_KEYWORDS_AS_ARCH " " (full / true / false)
Bei B<full> oder B<true> wird ARCH durch ACCEPT_KEYWORDS modifiziert.
Dadurch wird geregelt, welche Keywords als ARCH oder OTHERARCH betrachtet werden.
Der Wert B<full> beeinflusst außerdem das ursprüngliche Keywording durch ARCH.
.TP
.BR NONEXISTENT_IF_OTHER_OVERLAY " " (true / false)
Legt fest, ob Versionen bei TEST_FOR_NONEXISTENT als nicht-existent betrachtet
werden, wenn sie nur von einem anderen Overlay als die installierte Version kommen.
.TP
.BR NONEXISTENT_IF_MASKED " " (true / false)
Legt fest, ob maskierte Versionen bei TEST_FOR_NONEXISTENT. als nicht-existent
betrachtet werden.
.TP
.BR REDUNDANT_IF_DOUBLE " " (string)
Dies definiert den TEST_FOR_REDUNDANCY, der positiv ausfällt,
falls in /etc/portage/package.{accept_,}keywords das selbe Keyword zweimal
für einige/alle (un-/installierten) Versionen gelistet wird.

.RS
B<string> beschreibt dabei, welche Versionen getestet werden.
Die folgenden Werte sind dabei zulässig:
.TP
.BR no " oder " false
Teste nicht auf dies Art der Redundanz (keine der Versionen).
.TP
.B some
Der Test ist positiv, falls die Redundanz für irgendeine Version der Datenbank auftritt.
.TP
\fBall\fR
Der Test ist positiv, falls die Redundanz für alle Versionen der Datenbank auftritt.
.TP
.B some-installed
Der Test ist positiv, falls die Redundanz für eine installierte Version auftritt.
Uninstallierte Versionen werden dabei ignoriert.
.TP
.B all-installed
Der Test ist positiv, falls die Redundanz für alle installierten Versionen des
Pakets auftritt.
Falls keine Version installiert ist, ist der Test positiv, falls
die Redundanz für eine Version auftritt.
.TP
.B some-uninstalled
Der Test ist positiv, falls die Redundanz für eine uninstallierte Version auftritt.
Installierte Versionen werden dabei ignoriert.
.TP
.B all-uninstalled
Der Test ist positiv, falls die Redundanz für alle uninstallierten Versionen auftritt.
Falls alle Versionen installiert sind, ist der Test positiv, falls
die Redundanz für eine Version auftritt.
.TP
.BR "-" "etwas von Obigem   oder " "+" "etwas von Obigem"
Der Test erfolgt nur, wenn zusätzlich keine Version (im Falle B<->)
bzw. mindestens eine Version (im Falle B<+>) des Pakets instaliert ist.
.TP
.RB "etwas von Obigem  " or "  etwas von Obigem"
Der Test ist positiv, wenn mindestens einer der beiden Tests positiv ist.
Statt "B<or>"  können auch die Zeichen "B<|>" oder "B<||>" benutzt werden.
.RE

.TP
.BR REDUNDANT_IF_DOUBLE_LINE " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.{accept_,}keywords für die
entsprechenden Versionen zwei Zeilen für identische Ziele enthält,
d.h. so dass Portage die erste der Zeilen ignorieren würde.
Beachte, dass Zeilen mit den Zielen B<foo/bar> und B<=foo/bar-1> in diesem
Zusammenhang von Portage (und daher auch von eix) als verschiedene Ziele betrachtet
werden, selbst dann, wenn B<foo/bar> sich auf die Version B<1> bezieht.
Redundanzen von letzterem Typ können implizit mit B<REDUNDANT_IF_DOUBLE_LINE>,
B<REDUNDANT_IF_MIXED>, und B<REDUNDANT_IF_STRANGE> gefunden werden.
.TP
.BR REDUNDANT_IF_MIXED " " (string ", siehe oben")
Dies testet, ob
/etc/portage/package.{accept_,}keywords für die betreffenden Versionen
zwei verschiedene Keywords listet, z.B. ~ARCH und **
.TP
.BR REDUNDANT_IF_WEAKER " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.{accept_,}keywords für die
entsprechenden Versionen ein Keywords enthält,
das durch ein schwächeres Keyword ersetzt werden kann,
etwa **, ~OTHERARCH oder OTHERARCH statt ~ARCH, oder ~OTHERARCH statt OTHERARCH.
.TP
.BR REDUNDANT_IF_STRANGE " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.{accept_,}keywords für die entsprechenden Versionen
ein merkwürdiges Keywords enthält, etwas UNKNOWNARCH (weder im .ebuild noch in ARCH gelistet)
oder -OTHERARCH.
.TP
.BR REDUNDANT_IF_NO_CHANGE " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.{accept_,}keywords Keywords enthält,
die nicht den Stabilitätsstatus der entsprechenden Versionen ändern.
.TP
.BR REDUNDANT_IF_MASK_NO_CHANGE " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.mask Einträge enthält,
die nicht den Maskenstatus der entsprechenden Version ändern.
.TP
.BR REDUNDANT_IF_UNMASK_NO_CHANGE " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.unmask Einträge enthält
die nicht den Maskenstatus der entsprechenden Version ändern.
.TP
.BR REDUNDANT_IF_DOUBLE_MASKED " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.mask zweimal auf die
entsprechende Version zutrifft.
.TP
.BR REDUNDANT_IF_DOUBLE_UNMASKED " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.unmask zweimal auf die
entsprechende Version zutrifft.
.TP
.BR REDUNDANT_IF_DOUBLE_USE " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.use zweimal auf die
entsprechende Version zutrifft.
.TP
.BR REDUNDANT_IF_DOUBLE_ENV " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.env zweimal auf die
entsprechende Version zutrifft.
.TP
.BR REDUNDANT_IF_DOUBLE_LICENSE " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.license zweimal auf die
entsprechende Version zutrifft.
.TP
.BR REDUNDANT_IF_DOUBLE_RESTRICT " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.accept_restrict zweimal auf die
entsprechende Version zutrifft.
.TP
.BR REDUNDANT_IF_DOUBLE_CFLAGS " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.cflags zweimal auf die
entsprechende Version zutrifft.
Beachte, dass diese Datei von Portage nicht unterstützt wird,
aber sie könnte von einer lokalen /etc/portage/bashrc-Datei unterstützt werden.
Dies heißt natürlich, dass die Datei /etc/portage/package.cflags kein offiziell unterstützes Format hat.
eix nimmt an, dass das Format analog zu /etc/portage/package.{keywords,use} ist
(d.h. ein Eintrag ist höchstens eine Zeile mit den gewünschten Paketen/Versionen zu Beginn der Zeile).
Wie die anderen /etc/portage/package.*-Dateien kann /etc/portage/package.cflags auch ein Verzeichnisbaum sein.
In diesem Fall werden alle nicht-versteckten Dateien/Unterverzeichnisse dieses Baums
rekursiv gelesen, wobei alle symbolischen Links aufgelöst werden.
.TP
.BR REDUNDANT_IF_IN_KEYWORDS " " (string ", siehe oben")
Dies testet, ob /etc/portage/package.{accept_,}keywords einen nichtleeren
Eintrag für die betreffende Version enthält (leere Einträge findet man mit -t).
Natürlich wird man nicht alle Treffer als Redundanz betrachten
(obwohl man diese Option missbrauchen könnte, um alle Treffer zu listen).
Aber man könnte passende aber nicht-installierte Pakete als redundant betrachten.
Daher wird man diese Werte typischerweise auf den Wert B<-some> oder den
äquivalenten Wert B<-some-uninstalled> setzen
(oder auf B<false>, wenn man der Meinung ist, dass Einträge für uninstallierte
Pakete "normal" und nicht redundant sind).
.TP
.BR REDUNDANT_IF_IN_MASK " " (string ", siehe oben")
Dies ist analog zu B<REDUNDANT_IF_IN_KEYWORDS>, aber für /etc/portage/package.mask.
.TP
.BR REDUNDANT_IF_IN_UNMASK " " (string ", siehe oben")
Dies ist analog zu B<REDUNDANT_IF_IN_KEYWORDS>, aber für /etc/portage/package.unmask.
.TP
.BR REDUNDANT_IF_IN_USE " " (string ", siehe oben")
Dies ist analog zu B<REDUNDANT_IF_IN_KEYWORDS>, aber für /etc/portage/package.use.
.TP
.BR REDUNDANT_IF_IN_ENV " " (string ", siehe oben")
Dies ist analog zu B<REDUNDANT_IF_IN_KEYWORDS>, aber für /etc/portage/package.env.
.TP
.BR REDUNDANT_IF_IN_LICENSE " " (string ", siehe oben")
Dies ist analog zu B<REDUNDANT_IF_IN_KEYWORDS>, aber für /etc/portage/package.license.
.TP
.BR REDUNDANT_IF_IN_RESTRICT " " (string ", siehe oben")
Dies ist analog zu B<REDUNDANT_IF_IN_KEYWORDS>, aber für /etc/portage/package.accept_restrict.
.TP
.BR REDUNDANT_IF_IN_CFLAGS " " (string ", siehe oben")
Dies ist analog zu B<REDUNDANT_IF_IN_KEYWORDS>, aber für /etc/portage/package.cflags.
Siehe die obigen Bemerkungen zu dieser Datei.
.\" }}}
.\" {{{ Verschiedene Dateilisten:
.TP
.BR SLOT_UPGRADE_FORBID " " "(Stringliste)"
Dies ist eine Liste aller Datei/Verzeichnisnamen, die als /etc/portage/package.slot_upgrade_forbid dienen.
.TP
.BR SLOT_UPGRADE_ALLOW " " "(Stringliste)"
Dies ist eine Liste aller Datei/Verzeichnisnamen, die als /etc/portage/package.slot_upgrade_allow dienen.
.TP
.BR KEYWORDS_NONEXISTENT " " "(Stringliste)"
Dies ist eine Liste aller Datei/Verzeichnisnamen, die als /etc/portage/package.{accept_,}keywords.nonexistent dienen.
.TP
.BR MASK_NONEXISTENT " " "(Stringliste)"
Dies ist eine Liste aller Datei/Verzeichnisnamen, die als /etc/portage/package.mask.nonexistent dienen.
.TP
.BR UNMASK_NONEXISTENT " " "(Stringliste)"
Dies ist eine Liste aller Datei/Verzeichnisnamen, die als /etc/portage/package.unmask.nonexistent dienen.
.TP
.BR USE_NONEXISTENT " " "(Stringliste)"
Dies ist eine Liste aller Datei/Verzeichnisnamen, die als /etc/portage/package.use.nonexistent dienen.
.TP
.BR ENV_NONEXISTENT " " "(Stringliste)"
Dies ist eine Liste aller Datei/Verzeichnisnamen, die als /etc/portage/package.env.nonexistent dienen.
.TP
.BR LICENSE_NONEXISTENT " " "(Stringliste)"
Dies ist eine Liste aller Datei/Verzeichnisnamen, die als /etc/portage/package.license.nonexistent dienen.
.TP
.BR RESTRICT_NONEXISTENT " " "(Stringliste)"
Dies ist eine Liste aller Datei/Verzeichnisnamen, die als /etc/portage/package.accept_restrict.nonexistent dienen.
.TP
.BR CFLAGS_NONEXISTENT " " "(Stringliste)"
Dies ist eine Liste aller Datei/Verzeichnisnamen, die als /etc/portage/package.cflags.nonexistent dienen.
.TP
.BR INSTALLED_NONEXISTENT " " "(Stringliste)"
Dies ist eine Liste aller Datei/Verzeichnisnamen, die als /etc/portage/package.installed.nonexistent dienen.
.TP
.BR PACKAGE_NOWARN " " "(Stringliste)"
Dies ist eine Liste aller Datei/Verzeichnisnamen, die als  /etc/portage/package.nowarn dienen.
.\" }}}
.\" }}}

.\" {{{ /etc/portage/sets.eix
.SS /etc/portage/sets.eix
Dies Verzeichnis ist ähnlich wie B</etc/portage/sets> (siehe die Portage Manpage).
Da Portage einige Möglichkeiten hat, Sets zu definieren, die für eix nicht verfügbar sind,
kann man dieses Verzeichnis benutzen, um (statische) Sets zu speichern, von denen man will,
dass sie eix bekannt sind (so dass beispielsweise Sets-Einträge in
/etc/portage/package.{accept_,}keywords entsprechend behandelt werden können).
.\" }}}

.\" {{{ /etc/portage/package.slot_upgrade*
.SS /etc/portage/package.slot_upgrade_forbid
.SS /etc/portage/package.slot_upgrade_allow
Ähnlich wie alle anderen /etc/portage/package.* kann dies eine Datei oder ein Verzeichnis sein.
Die Einträge dieser Datei haben die Gestalt "category/name" (getrennt durch Zeilenvorschub).
Die entsprechenden Pakete werden als Ausnahmen für B<UPGRADE_TO_HIGHEST_SLOT> behandelt.
.\" }}}

.\" {{{ /etc/portage/package.*.nonexistent
.SS /etc/portage/package.{accept_,}keywords.nonexistent
.SS /etc/portage/package.keywords.nonexistent
.SS /etc/portage/package.mask.nonexistent
.SS /etc/portage/package.unmask.nonexistent
.SS /etc/portage/package.use.nonexistent
.SS /etc/portage/package.env.nonexistent
.SS /etc/portage/package.license.nonexistent
.SS /etc/portage/package.accept_restrict.nonexistent
.SS /etc/portage/package.cflags.nonexistent
Ähnlich wie /etc/portage/package.* kann dies eine Datei oder ein Verzeichnis sein.
Falls ein Eintrag (durch Leerzeichen oder Zeilenvorschub getrennt) auf das
erste Wort oder eine Zeile der entsprechenden /etc/portage/package.* Datei passt,
wird diese Zeile von Tests mit -t ausgenommen (für Namen, die nicht in der Datenbank sind).
Dies kann benutzt werden, um bestimmte Warnungen von -t auszuschalten.

.SS /etc/portage/package.installed.nonexistent
Dies ist ähnlich zu den anderen /etc/portage/package.*.nonexistent Dateien/Verzeichnissen
mit dem Unterschied, dass es Meldungen von -t über installierte Pakete ausschaltet,
die aus der Datenbank entfernt wurden.
Die Einträge dieser Datei haben die Gestalt "category/name", aber man kann auch
auf den "category/"-Teil verzichten (obwohl dies nicht empfehlenswert ist).
.\" }}}

.\" {{{ /etc/portage/package.nowarn
.SS /etc/portage/package.nowarn
Ähnlich wie /etc/portage/package.* kann dies eine Datei oder ein Verzeichnis sein.
Mit dieser Datei/Verzeichnis können Test mit -T für bestimmte Pakete unterdrückt werden.
Das Format dieser Datei ist ähnlich zu /etc/portage/package.use mit dem Unterschied,
dass man Tests an- oder abschalten kann.
Es werden alle Zeilen aktiv, für die mindestens eine passende Version verfügbar ist.
Beispielsweise bewirken die Zeilen

.B sys-kernel/*-sources no_change weaker

.B >sys-kernel/hardened-sources-2.6.40 -weaker

in dieser Datei, dass -T die Pakete sys-kernel/*-sources nicht meldet, wenn
der einzige Grund dafür wäre, dass B<REDUNDANT_IF_NO_CHANGE>
oder B<REDUNDANT_IF_WEAKER> gesetzt ist.
Eine Ausnahme dieser Regel gibt es nur für B<REDUNDANT_IF_WEAKER> und
hardened-sources, falls letzteres wenigestens in der Version 2.6.40 verfügbar ist.
Die Reihenfolge in der Datei spielt keine Rolle: Ein "-" hat stets Vorrang,
wenn es irgendwo auftaucht.

Man kann Pakete in dieser Datei wiederholt listen; die gelisteten Tests
wirken für das entsprechende Paket kumulativ.

Verfübare Tests sind:
B<in_keywords>, B<no_change>, B<double>, B<mixed>, B<weaker>, B<double_line>,
B<in_mask>, B<mask_no_change>, B<double_masked>,
B<in_unmask>, B<unmask_no_change>, B<double_unmasked>,
B<in_use>, B<double_use>,
B<in_env>, B<double_env>,
B<in_license>, B<double_license>,
B<in_restrict>, B<double_restrict>,
B<in_cflags>, B<double_cflags>.
Die Bedeutung entspricht der zugehörigen B<REDUNDNANT_IF_*>-Variablen.

Zusätzlich gibt es die Tests B<nonexistent>, B<masked>, B<other_overlay>,
deren Bedeutung den zugehörigen Variablen
B<TEST_FOR_NONEXISTENT>, B<NONEXISTENT_IF_MASKED>, B<NONEXISTENT_IF_OTHER_OVERLAY>
entspricht.
.\" }}}

.\" {{{ -------- @EIX_CACHEFILE@
.SS @EIX_CACHEFILE@
Dies ist die Binärdatenbank für eix.
Der Pfad kann mit der Variablen B<EIX_CACHEFILE> geändert werden
(deren Vorgabe B<EPREFIX> über verzögerte Ersetzung berücksichtigt).
.\" }}}

.\" {{{ -------- @EIX_PREVIOUS@
.SS @EIX_PREVIOUS@
Dies ist die vorhergehende Version von @EIX_CACHEFILE@,
die von eix-diff und eix-sync benutzt wird.
Der Pfad kann mit der Variablen B<EIX_PREVIOUS> geändert werden
(deren Vorgabe B<EPREFIX> über verzögerte Ersetzung berücksichtigt).
.\" }}}

.\" {{{ -------- @EIX_REMOTEARCHIVE1@ und @EIX_REMOTEARCHIVE2@
.SS @EIX_REMOTEARCHIVE1@ und @EIX_REMOTEARCHIVE2@
Dies ist eine lokale Kopie des Remote-Archivs, das von eix-remote benutzt wird.
Der Pfad kann mit der Variablen B<EIX_REMOTEARCHIVE1> bzw. B<EIX_REMOTEARCHIVE2>
geändert werden (deren Vorgaben B<EPREFIX> über verzögerte Ersetzung berücksichtigen).
.\" }}}
.\" }}}

.\" {{{ masked-packages
.SH masked-packages
B<masked-packages> ist ein Hilfsprogramm für Skripte, das die Argumente gegen
eine Liste von Paketmasken testet.
Die Masken werden durch die Optionen spezifiert; sie sollten im selben Format
sein wie /etc/portage/package.mask
Die Argumente werden in der Form I<Kategorie>B</>I<Name>B<->I<Version>[B<:>I<Slot>][B<::>I<Repo>] erwartet.
Als Vorgabe werden die Argumente ausgegeben, die auf eine Maske passen.

.SS Beispiele:
.TP
.B masked-packages -q --file /etc/portage/package.accept_keywords app-portage/eix-99999999::mv
Kehrt erfolgreich zurück, falls ein Eintrag aus B</etc/portage/package.accept_keywords> auf
die Version B<app-portage/eix-99999999::mv> passt.
.TP
.B masked-packages -m '=a/b-1*:1' -m '=c/d-1' a/b-0:1 a/b-1.1:1 a/b-1.2 c/d-1:2
Gibt nur B<a/b-1.1:1> und B<c/d-1:2> aus, da bei den anderen Argumenten
Version bzw. Slot nicht auf die Maske passen.

.SS Optionen
.TP
.BR -h ", " --help
Ausgabe eines Hilfstextes und Ende.
.TP
.BR -q ", " --quiet "   (toggle)"
Anstelle der Ausgabe der Argument wird nur anhand des Rückgabewerts gezeigt,
ob ein Argument gepasst hat.
Genauer ist der Rückgabewert nur dann erfolgreich, wenn mindestens ein Argument passt.
.TP
.BR -Q ", " --nowarn "   (toggle)"
Keine Ausgabe von Warnungen bzgl. falscher Syntax.
.TP
.BR -m ", " --mask " " I<MASKE>
Fügt I<MASKE> der Maskenliste hinzu.
.TP
.BR -f ", " --file " " I<DATEI>
Fügt die Zeilen von I<DATEI> der Maskenliste hinzu.
I<DATEI> kann auch leer sein oder B<-> oder ein Verzeichnis:
Ein leerer Filename oder B<-> wird als Standardeingabe interpretiert,
ein Verzeichnis wird rekursiv gelesen.
.TP
.BR -F ", " --read-file " " I<DATEI>
Fügt alle Worte aus I<DATEI> der Liste von Argumenten hinzu.
I<DATEI> kann auch leer sein oder B<-> oder ein Verzeichnis:
Ein leerer Filename oder B<-> wird als Standardeingabe interpretiert,
ein Verzeichnis wird rekursiv gelesen.
.\" }}}

.\" {{{ versionsort
.SH versionsort
B<versionsort> ist ein Hilfstool für Skripte, das zwei Zwecken dient:
Es schneidet den Versionsstring und verschiedenen nicht-alphanumerischen Müll
von seinen Argumenten ab und interpretiert diese Argumente selbst als
Versionsstrings (nach einer Heuristik).
Dann gibt es alle diese Versionsstrings in sortierter Reihenfolge aus,
wobei die Portage-Regeln der Versionssortierung berücksichtigt werden.
Bei mehr als einem Argument wird nach jeder Version (einschließlich der letzten)
ein Zeilenvorschub ausgegeben.
Beispiel:

.RS
.B versionsort '>=gcc-4.4' 4.4_alpha0 '<sys-devel/gcc-4.05' 4.5
.RE

wird folgendes ausgeben:

.RS
.B 4.05

.B 4.4_alpha0

.B 4.4

.B 4.5
.RE

Falls nur ein Argument übergeben wird, ist versionsort weniger streng
bzgl. der Versionsregeln; selbst wenn der Versions-Teil nicht vollständig
korrekt ist, wird in diesem Fall garantiert, dass die Ausgabe zeichengleich
mit dem Versionsteil ist.
Daher kann versionsort mit einem Argument benutzt werden, um in einem
Shellskript den Paketnamen vom Versionsteil abzutrennen, etwa so:

.RS
B<split=1-font-adobe-75dpi-1.3-r1>

B<version=`versionsort "X$split"`; name=${split%"-$version"}>
.RE

Obwohl es derzeit keinen Unterschied macht, ist es zukunftssicherer
(bzgl. möglicher künftiger Änderungen des Versionsformats)
das Argument mit einer Nicht-Ziffer (wie B<X> in obigem Beispiel)
beginnen zu lassen, um sicherzustellen, dass versionsort tatsächlich
die Version abtrennt und nicht fälschlicherweise das gesamte Argument
als eine einzige Version interpretiert.

Seit eix-0.25.6 unterstützt versionsort auch einige Optionen:
Mit B<-n>, B<-p>, B<-f>, B<-v>, B<-r> bzw. B<-V> wird nur der Name (ohne Versionsanhang),
Name mit Version (ohne Revisionsanhang), Name mit Version und Revisionsanhang,
die reine Version (ohne Revisionsanhang), die Revision bzw. Version mit Revisionsanhang ausgegeben.
(Seit eix-0.29.5 ist es zulässig, nach diesen Optionen eine beliebige Anzahl von Argumenten anzugeben;
bei mehr als einem Argument wird an jede Ausgabe ein Zeilenvorschub angehängt).
Beispielsweise wird

.RS
B<split=1-font-adobe-75dpi-1.3-r1>

B<PN=`versionsort -n "$split"`>

B<P=`versionsort -p "$split"`>

B<PF=`versionsort -f "$split"`>

B<PV=`versionsort -v "X$split"`>

B<PR=`versionsort -r "X$split"`>

B<PVR=`versionsort -V "X$split"`>
.RE

die Variablen B<PN>, B<P>, B<PF>, B<PV>, B<PR>, B<PVR> analog wie in ebuilds definieren:
Als B<1-font-adobe-75dpi>, B<1-font-adobe-75dpi-1.3>, B<1-font-adobe-75dpi-1.3-r1>, B<1.3>, B<r1> bzw. B<1.3-r1>
(falls B<-r1> nicht angegeben worden wäre, wäre B<PR> leer: Dies ist anders als in ebuilds).

Beachten Sie, dass B<versionsort> nur bei den Optionen B<-n>, B<-p> und B<f> erwartet, dass das Argument einen Paketnamen enthält:
Bei allen anderen Optionen (oder ohne Option) wird durch Vorstellen des "X" klargestellt, dass es sich nicht um eine "reine" Versionsnummer handelt.
.\" }}}


.\" {{{ FEHLER
.SH "FEHLER (und Antworten auf einige häufig gestellte Fragen)"
.LP
Für Fehlermeldungen benutzen Sie bitte I<@PACKAGE_BUGREPORT@> oder
Gentoos Bugzilla I<https://bugs.gentoo.org/>

Viele Cache-Methoden sind prinzipbedingt sehr langsam.
Benutzen Sie die Hinweise im speziellen Abschnitt B<BESCHLEUNIGUNG> weiter unten.

eix kann nicht zuverlässig die Farbmöglichkeiten und Hintergrundfarbe Ihres Terminal feststellen;
dies ist gerade dann besonders ärgerlich, wenn Sie ein transparentes Terminal benutzen oder die Vorgabe-Hintergrundfarbe von
beispielsweise xterm auf Schwarz geändert haben.
Hier sind einige einfache Methoden, wie sie einige ungewünschte Farbprobleme vermeiden können
(zum Detailverständnis dieser Methoden schlagen Sie bitte die weiter oben stehende Beschreibung
der Variablen B<TERM_ALT?>, B<SOLARIZED>, B<COLORSCHEME?>, B<DARK>, B<TERM_DARK> und B<COLORFGBG_DARK> nach):

.TP
1. Benutzen Sie das Farbschema zu ihrer tatsächlichen Hintergrundfarbe, indem Sie B<DARK=true> oder B<DARK=false> in I<@SYSCONFDIR@/eixrc> setzen (oder in indem Sie die Heuristik aus B<TERM_DARK> an Ihr System anpassen.)

.TP
2. Erzwingen Sie die korrekte Hintergrundfarbe (oder vermeiden Sie deren Setzen), indem Sie B<BG0=black>, B<BG1=black>, B<BG2=white>, B<BG3=white> (oder B<BG0=none>, B<BG1=none>, B<BG2=none>, B<BG3=none>) in I<@SYSCONFDIR@/eixrc> setzen. Beachten Sie, dass das Erzwingen der Hintergrundfarbe transparente Terminals intransparent machen kann und dass darüberhinaus bei einige Terminals auch neu hereingescrollte Zeilen in dieser Hintergrundfarbe sein können. Um die erzwungene Hintergrundfarbe bei jedem Zeilenende (nicht) zurückzusetzen, können Sie B<RESET_ALL_LINES=false> bzw. B<RESET_ALL_LINES=true> setzen (die Vorgabe kann von der eix-Version abhängen).

.TP
3. Erzwingen Sie ein gewünschtes Farbschema auf allen Terminals indem Sie B<TERM_ALT3=.> in I<@SYSCONFDIR@/eixrc> setzen; dies kann mit B<COLORSCHEME3=0> (oder B<=1>, ..., B<=5>) kombiniert werden. Beachten Sie, dass die Farbschemas 0 und 2 sehr armselig sind, da sie nur die wenigen Systemfarben benutzen und daher verschiedene Dinge farblich nicht immer unterscheidbar sind. Dennoch kann dies sinnvoll sein, wenn Sie beispielsweise regelmäßig verschiedene Terminals benutzen und sich nur an ein einziges Farbschema gewöhnen wollen oder wenn Sie Ethan Schoonovers B<originales> Farbschema erzwingen wollen. Benutzer von Solarized sollten in jedem Fall B<SOLARIZED> setzen und Farbscheme 5 (oder 4) benutzen:

.TP
4. Wenn Sie Ihr Terminal auf Ethan Schoonovers Solarized Farbschema (hell oder dunkel) konfiguriert haben, setzen Sie einfach B<SOLARIZED=true> (oder light oder dark - bzgl. eix ist das alles äquivalent). Benutzen Sie den vorherigen Hinweis nur für den Fall zusätzlich, dass es ihnen nicht passt, dass für 256-farbige Terminals zusätzliche Farben benutzt werden.

.TP
5. Wenn Sie ein rxvt benutzen, das 256 Farben beherrscht, dass aber nicht TERM=rxvt-256color oder TERM=rxvt-unicode-256color setzen, setzen Sie B<TERM_ALT1_ADD=rxvt> in I<@SYSCONFDIR@/eixrc>.
.LP
eix beherrscht keine Abhängigkeiten und/oder USE-Flags und wird das
vermutlich auch niemals tun.
Insbesondere heißt dies, dass die Ausgabe von eix -u i.a. etwas anderes liefert
als ein emerge update-Kommando - das Letztere ist zuverlässiger.
Dies gilt insbesondere auch für das Upgraden von Paketen mit Slots.
Die Variable B<UPGRADE_TO_HIGHEST_SLOT> und händische Ausnahmen
in B</etc/portage/package.slot_upgrade_forbid> bzw. B</etc/portage/package.slot_upgrade_allow>
können benutzt werden, um diesen Nachteil von eix abzufedern.

eix beherrscht nicht alle Sets, die Portage unterstützt, und wird das vermutlich auch niemals tun.
Derzeit scheint es, dass sogar der vorgeschlagene Weg, Sets in den Portagebaum
über PROPERTIES=set einzubauen, von eix nicht unterstützt werden wird
(weil eix Abhängigkeiten und USE-Flags kennen müsste, um dies zu unterstützen).
Als eine Notlösung kann man manuell solche zusätzlichen Sets in
B</etc/portage/sets.eix> definieren.
Darüberhinaus beherrscht eix nicht das Lesen von sets.conf-Dateien und wird das vermutlich auch niemals tun.
Falls zusätzliche B<sets/>-Verzeichnisse etwa in einem Overlay angegeben wurden,
müssen diese zusätzlichen Verzeichnisse manuell in I<@SYSCONFDIR@/eixrc> zur
Variablen B<EIX_LOCAL_SETS> hinzugefügt werden.
Der leichteste Weg zu Letzterem ist es, einen Eintrag der Art

B<EIX_LOCAL_SETS_ADD=">I</path/to/overlay1/sets> I</path/to/overlay2/sets> I<...>B<">

nach I<@SYSCONFDIR@/eixrc> zu schreiben (vgl. die frühere Beschreibung von B<EIX_LOCAL_SETS>).

eix-diff ignoriert /etc/portage/profile. (Grund: Die gespeicherte Datenbank
enthält nur den Maskierungsstatus entsprechend des ursprünglichen Profils,
aber nicht das Profil selbst.
Andererseits kann /etc/portage/profile nur dann interpretiert werden, wenn
das Profil bekannt ist).

Die Ausgabe mit der Standardeinstellung B<OVERLAYS_LIST=all-used-renumbered> ist irritierend,
wenn man die Overlaynummer in einer eix-Variablen oder -Kommando-Argument benutzen will.

Es gibt keine Cachemethode, das die Information aller Overlays
(für die es keinen Portage-Metadatencache gibt) schnell und zuverlässig holt:
Man muss immer eines dieser beiden Extreme wählen.
Die Standardeinstellung ist schnell, aber sie liefert oft falsche Slots und hat andere Probleme.

Das ganze B<EPREFIX>/B<ROOT>-Zeugs ist sehr verwirrend.
Insbesondere wird eix durch die bloße Tatsache, viele dieser Variablen zu berücksichtigen,
stets verwundbar gegen lokale Angriffe sein, wenn es in einer möglicherweise kompromitierten
Environment gestartet wird.

Die frühere Vorgabe B<KEEP_VIRTUALS=true> verwirrte viele Leute.
Mit der neuen Vorgabe findet leider fast niemand heraus, dass dieses Feature existiert.
:(

Es gibt zu viele Features: Dokumentation und Konfiguration sind zu kompliziert geworden.
Andererseits gibt es immer noch eine Menge Dinge, die nicht konfiguriert werden können...
.\" }}}

.\" {{{ BESCHLEUNIGUNG
.SH "BESCHLEUNIGUNG"
.LP
Alle Nicht-Metadaten-basierten Cachemethoden für B<eix-update> sind entweder unzuverlässig (B<parse>, B<parse*>) oder langsam und unsicher (B<ebuild>, B<ebuild*>).
Daher wird empfohlen, Metadaten zu erzeugen und sie für den Hauptbaum und alle Overlays zu benutzen.
Die Vorgaben von eix sind so, dass diese Metadaten benutzt werden, sofern vorhanden (siehe B<CACHE_METHOD_PARSE>)
(Konfiguration ist nur im Falle des sqlite-Backends von Portage erforderlich).
Im Wesentlichen gibt es zwei Arten möglicher Metdaten, die benutzt werden können:

.TP
1. Metadaten, die jeweils im Baum/Overlay gespeichert werden.

Diese Daten liegen im metadata/cache oder metadata/md5-cache-Unterverzeichnis von $PORTDIR bzw. vom entsprechenden Overlay.

.TP
2. Metadaten, die von Portage für jeden Baum/Overlay in I</var/cache/edb/> gespeichert werden.

Diese Daten werden mit B<emerge --metadata> erzeugt (und ihr Format hängt davon ab, ob Portage das sqlite-Backend benutzt).

.LP
Der Nachteil bei der Benutzung von Metadaten ist, dass sie vor dem Aufruf von B<eix-update>
generiert bzw. auf den neuesten Stand gebracht werden müssen, sobald der entsprechende Baum/Overlay geändert wird,
sowie im Falle von den Metadaten von I</var/cache/edb>, dass sie zusätzlichen Platz benötigen.

Glücklicherweise muss man sich nicht um Metadaten um Hauptbaum kümmern, da
das metadata/{md5-,}cache-Unterverzeichnis von $PORTDIR automatisch mit B<emerge --sync> auf den neuesten Stand gebracht wird.
Der lokale Overlay allerdings und etliche Overlays, die von layman o.a. behandelt werden,
enthalten keine Metadaten (und selbst wenn sie es tun, sind diese nicht immer aktuell),
und daher sollten Metadaten dieser Overlays generiert werden, um B<eix-update> zu beschleunigen.

B<Vorsicht:> Metadaten zu erzeugen ist ein Sicherheitsrisiko, da alle Ebuilds des Baums dazu ausgeführt werden!
Andererseits müssen Sie Overlays ohnehin vertrauen, wenn Sie sie nutzen...

Ich empfehle B<nicht> die Benutzung von B<emerge --metadata> (obwohl dies automatisiert leich
zum richtigen Zeitpunkt ausgeführt werden könnte, indem man B<eix-sync> mit der Option B<-M> benutzt:
Man müsste nur die Zeile B<-M> in B</etc/eix-sync.conf> einfügen),
denn es wäre eine Verschwendung von Plattenplatz, die Metadaten des ganzen Portage-Baums
als Duplikat nach I</var/cache/edb> zu speichern.

Stattdessen empfehle ich, die Metadaten in den Overlays bei jedem B<eix-sync> zu aktualisieren.
Dies kann ebenfalls automatisiert zu richtigen Zeitpunkt geschehen, aber es erfordert ein
etwas komplizierteres Setup:

Für einen lokalen Overlay - der Einfachheit halber nehmen wir an, er liege in I</usr/local/portage>,
und dass dieser Pfad in B<PORTDIR_OVERLAY> enthalten ist - geht man wie folgt vor:

Als erstes muss man dem Overlay einen Namen geben, falls nicht bereits geschehen:
Dieser kommt in des File I</usr/local/portage/profiles/repo_name> (das ggf. zu erzeugen ist).
(Dieser Schritt sollte unabhängig von eix oder Metadaten ohnehin immer geschehen).
Ich nehme ab jetzt an, dass dieser Name I<mein_lokaler_Overlay> lautet.

Als zweites muss man angeben, welcher Typ von Metadaten gewünscht ist:
Dazu kommt in die Date I</usr/local/portage/metadata/layout.conf>
(die ggf. neu anzulegen ist), die Zeile

B<cache-formats = md5-dict>

sowie, außer man hat Gründe das nicht zu tun, ebenfalls die Zeile

B<thin-manifests = true>

Das erste weist Portage an nur die Metadaten in
I</usr/local/portage/metadata/md5-cache> zu erzeugen/benutzen
(was die neue Methode ist und der alten vorgezogen werden sollte).
Die andere Zeile hat nichts mit Metadaten zu tun sondern bedeutet nur,
dass die Manifest-Dateien im Overlay keine Checksummen der Dateien aus
I</usr/local/portage> enthalten müssen/werden.

Ab jetzt kann man jederzeit durch den Aufruf

B<egencache --repo=>I<my_local_overlay> B<--update>

oder (falls der Overlay über kein aktuelles I<profile/use.desc> verfügt):

B<egencache --repo=>I<my_local_overlay> B<--update --update-use-local-desc>

die Metadaten erzeugen bzw. auf den neuesten Stand bringen.
Beachten Sie, dass für den Fall, dass der Overlay eclassen vom Hauptbaum benutzt,
der obige Befehl auch dann ausgeführt werden muss, wenn sich die eclassen ändern,
also nach jedem B<emerge --sync>.
Um den obigen Befehl automatisch im richtigen Moment auszuführen, gibt es
mehrere Methoden:

Eine Methode besteht darin, ein ausführbares Shell-Skript in das Verzeichnis
I</etc/portage/repo.postsync.d/> zu legen, das B<egencache>
auf geeignete Weise in Abhängigkeit vom Repository-Namen B<$1> aufruft.
Beispielsweise kann man ein ausführbares File
I</etc/portage/repo.postsync.d/50-egencache> mit folgendem Inhalt anlegen:

.RS
#!/bin/sh

[ -z "$1" ] && exit

case $1 in

# Für Repositories "mv" und "local" auch profile/use.desc aktualisieren:

mv|local)

.RS
    exec egencache "--repo=$1" --update --update-use-local-desc;;
.RE

# Für alle anderen Repositories nur die Metadaten:

*)

.RS
    exec egencache "--repo=$1" --update;;
.RE

esac
.RE

Wenn dieses Shell-Skript ausführbar ist, wird B<egencache> nach jedem
B<emerge --sync> aufgerufen.

Eine Alternative besteht darin, B<egencache> (nur) automatisch bei jedem
Aufruf von B<eix-sync> auszuführen.
Fügen Sie dazu die folgenden Zeilen in I</etc/eix-sync.conf> ein:

B<@StatusInfo 'Erzeuge Metadaten für> I<mein_lokaler_Overlay><'>

B<@egencache --repo=>I<mein_lokaler_Overlay> B<--update --update-use-local-desc>

In ähnlicher Weise können auch beispielsweise alle Overlays gehandhabt werden, die von layman aktualisiert werden:
Fügen Sie einfach für jeden Layman-Overlay entsprechende B<egencache>-Aufrufe in F</etc/eix-sync.conf> ein.
(Seien Sie dabei allerdings nochmals gewarnt, dass dies ein Sicherheitsrisiko darstellt,
weil es bedeutet, dass die Ebuilds in den Overlays bei B<eix-sync> ausgeführt werden).

Unabhängig davon, welche Methode Sie verwenden: Für layman-Overlays gibt es noch ein weiteres Problem.
Je nach Versionskontrollsystem des Overlays kann sich layman weigern,
den Overlay zu synchronisieren, wenn Daten in das metadata/-Unterverzeichnis
geschrieben wurden, oder layman kann dieses Verzeichnis beim Synchronisieren löschen.

Für Overlays, die mit git gehandhabt werden, kann dieses Problem folgendermaßen gelöst werden:
Erzeugen Sie im Hauptverzeichnis dieses Overlays die Datei I<.gitignore>
(wenn sie nicht bereits existiert), and fügen sie ihr die beiden Zeilen

B</.gitignore>

B</metadata/>

hinzu: Dies bewirkt, dass das File .gitignore selbst sowie das
Unterverzeichnis metadata (und sein Inhalt) von git/layman bei obigem
Aufruf ignoriert (insbesondere nicht verändert) werden.
.\" }}}

.\" {{{ INSTALLATION
.SH "INSTALLATION"
Es ist Gentoo-Politik, die B<CXXFLAGS> und B<LDFLAGS> des Benutzers nicht zu modifizieren.
Es ist ebenfalls Gentoo-Politik Voreinstellungen nicht zu ändern, wenn sie auf
andere Weise weise konfiguriert werden können.

Aus diesem Grund wurden viele ehemalige USE-Flags aus dem Gentoo Ebuild entfernt.
Daher ist es B<sehr wahrscheinlich>, dass Ihre B<./configure>-Optionen nicht
für eix passen. Der Maintainer von eix B<empfiehlt sehr> den Export von

.B EXTRA_ECONF="--enable-security --enable-new-dialect --enable-strong-optimization"

(Am Ende des Abschnitts steht, wie man das am besten macht).
Der Zweck ist es, B<CXXFLAGS> und B<LDFLAGS> auf eine Art zu modifizieren,
die eix stark optimiert (und für gewöhnlich die Größe des Binärprogramms
und entsprechende Speichernutzung enorm reduziert) und zudem so verändert, dass
es einigermaßen sicher ist (bzgl. *FLAGS), die Programme als Benutzer B<root> zu verwenden.
Natürlich sind die damit gewählten *FLAGS etwas experimentell, aber eix ist
so geschrieben, dass sie unterstützt werden sollten.
Wem das zu experimentall erscheint, der kann natürlich B<--enable-strong-optimization>
durch B<--enable-optimization> ersetzen. Man kann auch B<--enable-new-dialect> weglassen.
Beide Änderungen werden für gewöhnlich in schlechter optimiertem Code resultieren.
Umgekehrt kann man auch B<--enable-security> durch B<--enable-strong-security>
ersetzen, das einige (experimentelle) *FLAGS (falls vorhanden) auswählt, die die
Sicherheit erhöhen, allerdings auf merkliche Kosten der Ausführungsgeschwindigkeit.

Wenn Sie für Systeme mit wenig Speicher kompilieren, kann es auch ratsam sein,

.B --without-dep-default

.B --without-src-uri-default

und/oder

.B --without-required-use-default

zu dem obigen B<EXTRA_ECONF> hinzuzufügen. Letzteres ist ähnlich, wie wenn Sie
B<DEP=false> und/oder B<REQUIRED_USE=false> einer Datei in B</etc/eixrc/>
setzen: Es reduziert den von eix benötigten Speicher, indem es das Speichern
der entsprechenden Daten vermeidet.

Einige speziellere Optionen, die Sie zu B<EXTRA_ECONF> hinzufügen können, sind

.B --enable-warnings --enable-strong-warnings --debugging

mit Ihrer offensichtlichen Bedeutung bzgl. *FLAGS.
Weitere B<EXTRA_ECONF>-Argumente, die früher die USE-Flags zugänglich waren, sind:

.BR --enable-swap-remote " (Vertauschen der Rollen der beiden Remote-Adressen von " eix-remote ")"

.BR --enable-separate-tools " (build separate small binaries for the tools instead of linking them into the eix binaries)"

Der eix Maintainer empfiehlt die Konfiguration des Paketmanagers, um die
gewünschte B<EXTRA_ECONF> automatisch beim Emerge von eix zu setzen.
Für portage kann das wie folgt geschehen: Fügen Sie die Zeile

.B app-portage/eix eix-extra-econf.conf

der Datei I</etc/portage/package.env> (oder einer Datei in diesem Verzeichnis) hinzu.
(Erzeugen Sie dabei diese Datei bzw. Verzeichnis falls es noch nicht existiert).
Erzeugen Sie dann die Datei I</etc/portage/env/eix-extra-econf.conf> mit der
gewünschten Zeile B<EXTRA_ECONF=">I<...>B<">.

Alternativ kann eix vom mv overlay installiert werden.
Damit erhält man zusätzlich die experimentelle Möglichkeit, eix mit dem meson Build-System (statt autotools) zu bauen.
Falls dies auf Ihrem System läuft, ist es vorzuziehen, da es schneller ist und besser mit ccache zusammenarbeitet.
Aktuell (zum Zeitpunkt, wo dieser Text entsteht) ist es nicht möglich, eix mit dem Ebuild aus dem Gentoo Hauptbaum mit meson zu bauen.
.\" }}}

.\" {{{ GESCHICHTE
.SH "GESCHICHTE"
.LP
B<eix> war ursprünglich als B<portagedb> bekannt.
Der Name wurde geändert, weil ein Teil von Portage ebenfalls portagedb heißt,
was für alle etwas verwirrend war.

Die Funktionalität von eix-update wurde früher durch eine Option -u von eix erreicht.
Dies wurde dann für leichtere Wartbarkeit abgetrennt.
So kam B<update-eix> ins Leben.
Inzwischen ist es das gleiche Programm, dessen Funktionalität durch den Aufrufnamen festgelegt wird,
und der ursprüngliche Name update-eix wurde nach B<eix-update> umbenannt.

Auch B<eix-diff> hieß früher B<diff-eix>,
B<eix-remote> hieß früher B<update-eix-remote>,
B<eix-layman> hieß früher B<update-eix-layman>, und
B<eix-functions.sh> hieß früher B<functions-eix.sh> (und viel früher B<update-eix-functions.sh>).
Der Grund für all diese Umbenennungen ist ein konsistenteres Namensschema:
Alle mit eix verbundenen Programme beginnen jetzt mit eix-* (nur mit Ausnahme
von B<versionsort>, das aber ohnehin mehr oder weniger unabhängig ist).

Falls Sie sich nicht an diese neuen Namen gewöhnen können, oder falls Sie alte
Skripte haben, die die alten Namen benötigen, können Sie symbolische Links
für die alten Namen benutzen; dies ist ausdrücklich zulässig, und es ist
nicht geplant, die Unterstützung dafür fallenzulassen.

Früher gab es eine B<./configure>-Option, um solche symbolischen Links
oder eine Erinnerung an ihre Entfernung automatisch zu installieren,
aber diese Option wurde in eix-0.24.0 entfernt.

Durch die Einführung der %{*VARIABLE}-Syntax in eix-0.8.0 ist es nicht mehr
vernünftig, verschiedene Variablennamen für eix und eix-diff zu benutzen.
Daher wurden alle entsprechenden B<DIFF_*>-Variablen entfernt.

Die Cachemethode B<metadata-flat> hieß früher einfach nur B<metadata>.
Die Cachemethode B<assign> hieß früher B<backport> oder B<portage-2.1>.
Die Cachemethode B<flat> hieß früher auch B<portage-2.0>, und dieser Name wurde sogar bevorzugt.
Die obsoleten Namen werden nach wie vor unterstützt.

portage-2.1 und portage-2.1.1 löscht nicht das alten dep-Cachedirectory,
so dass eix mit der B<flat>/B<assign>-Cachemethode Pakete finden könnte,
die es gar nicht mehr im Portagebaum gibt.
Um dies zu vermeiden, hatte eix-sync den alten Cache gelöscht
(rm -rf /var/cache/edb/dep/*).
Da die meisten Nutzer diese Cachemethode nicht mehr benutzen müssen,
und das Löschen des alten Caches den nächsten Start von Portage verlangsamt,
ist dies nicht mehr die Vorgabe (aber immer noch als Option verfügbar,
die man nach I<@SYSCONFDIR@/eix-sync.conf> schreiben kann).

eix-sync benutzte früher gensync statt layman.
In der Beschreibung von I<@SYSCONFDIR@/eix-sync.conf> erfährt man, wie man
das obsolete gensync benutzen könnte.

eix-sync unterstützt kein Loggen mehr; die Optionen -v und -V wurden entfernt.
Damit werden Probleme wie unsichtbare Ausgaben bei EMERGE_DEFAULT_OPTS=--ask vermieden.
Man muss jetzt selbst Ausgabeumleitungen benutzen, wenn man eix-sync in einem cronjob benutzen will.

Der Mechanismus, der jetzt über B<DEFAULT_MATCH_FIELD> funktioniert, hat sich geändert.
Die früheren (weniger mächtigen) Variablen B<MATCH_.*_IF> und B<MATCH_ORDER> werden nicht mehr unterstützt.

Die Variablen B<ADD_CACHE_METHOD> und B<ADD_OVERRIDE_CACHE_METHOD> sind nicht länger
fest eingebaut, sondern werden nur implizit durch verzögerte Ersetzung in den Vorgaben
von B<CACHE_METHOD> und B<OVERRIDE_CACHE_METHOD> ausgewertet.
Insbesondere wird also Setzen der letzten beiden Variablen in I<@SYSCONFDIR@/eixrc> ohne
Hinzufügen der verzögerten Ersetzung " B<%{ADD_CACHE_METHOD}>" bzw. " B<%{ADD_OVERRIDE_CACHE_METHOD}>"
den ersten Variablen ihre Bedeutung vollständig nehmen.

Vor eix-0.18.0 gab es keine anpassbaren Ausgabe von Versionen wie mit
.BI "<installedversions:" "VAR" ">"
oder
.BI "<availableversions:" "VAR" ">".
Statt dessen gab es ein Parameterchaos für
.B "<installedversions:*>"
und eine große Liste von Varianten zur Ausgabe verfügbarer und installierter
Versionen zur Benutzung in Skripten wie etwa
.BR "<fullvailableversions>"
usw.
Mittlerweile ist dies alles verschwunden:
Die Variablen B<NAMEVERSIONS>, B<EQNAMEVERSION>,
B<ANAMESLOT>, B<ANAMEASLOT>, B<NAMESLOT>, B<NAMEASLOT>, und B<DATESORT>
übernehmen die Rolle der früheren Varianten (wobei B<DATESORT> ein
verwandtes Beispiel aufzeigt, das früher nicht möglich war).
Details findet man in der Beschreibung diesr Variablen in B<eix --dump>.
Der Effekt eines solchen Beispiels ist etwa hier zu sehen:

.B eix --format '<availableversions:ANAMESLOT:ANAMESLOT>' --pure-packages gcc

Siehe auch die Kommentare zur Option B<-I>.

Seit eix-0.20.0 haben sich die logischen Verknüpfungen für AUSDRUCK dramatisch geändert:
Jetzt sind nicht nur Klammern möglich sondern auch Ketten mit B<-a> und B<-o> werden nun
links-assoziativ behandelt, was wohl die meisten Anwender intuitiv erwarten.
Die Negation B<--not> wird nun als logischer Operator behandelt, der einen neuen KLAMMER_ODER_TEST startet
und nicht mehr als Teil der TEST_OPTIONEN (was oft zu Konfusion geführt hatte).
Jetzt wird auch B<--pipe> als Teil der TEST_OPTIONEN behandelt und induziert nicht mehr implizit logische Verknüpfungen.

Seit eix-0.20.1 werden die früher benutzten Dateien /etc/portage/package.*.nowarn
als Standardeinstellung nicht mehr unterstützt: Sie wurden durch die einzige Datei/Verzeichnis
/etc/portage/package.nowarn ersetzt.
Um die alten Dateien weiterhin zu nutzen, kann man B<OBSOLETE_NOWARN=true> setzen.
Mit der Beschreibung der Variablen B<PACKAGE_NOWARN> (in der Ausgabe von B<eix --dump>)
kann man verstehen, weshalb dies funktioniert.

B<eix-installed> war Teil von B<eix-test-obsolete> vor eix-0.22.4,
was ziemlich verwirrend für Benutzer und schwer zu warten war,
da diese beiden Aufgabe nichts gemeinsam hatten.

Das voreingestellt Fehlerverhalten von B<eix-sync> hat sich in eix-0.23.10 geändert:
Früher war die Option B<-F> automatisch und konnte nicht abgestellt werden.

Bei <eix-0.25.6 gab es eine B<NEWLINE>-Variable, die nach einem Paket einen automatischen Zeilenvorschub ausgeben konnte.
Dieser Hack war nur für obsolete FORMAT-Strings eingeführt worden und wurde wieder entfernt.

Die Variablen B<COLORSTRING>, B<COLORSTRING_ALT> und B<TERM_ALT> wurden durch die flexibleren
Variablen B<COLORSTRING?> und B<TERM_ALT?> ersetzt.

In B<eix-remote> vor eix-0.28.5 war die jetzige Option B<-x> die Standardeinstellung.
Diese erscheint nach wie vor ein vernünftige Standardeinstellung, aber das Feature irritierte Benutzer
(einige hielten es sogar für einen Bug), so dass es jetzt manuell als Vorgabe
festgelegt werden muss (durch Setzen von B<EIX_REMOTE_OPTS=-x> in I</etc/eixrc>).

Das Hilsprogramm B<eix-header> existiert erst seit eix-0.28.6; stattdessen hatte eix die
Optionen B<--is-current>, B<--print-overlay-path>, B<--print-overlay-label> und B<--print-overlay-data>,
die nun redundant wären und daher entfernt wurden.

Seit eix-0.29.6 gibt es die Optionen B<--format-verbose> und B<--format-compact> nicht mehr,
denn deren Wirkung kann besser durch Exportieren der Environment-Variablen
B<FORMAT_VERBOSE> bzw. B<FORMAT_COMPACT> erreicht werden.
Statt dessen überschreibt die Option B<--format> jetzt den B<FORMATSTRING> unabhängig vom gewählten Format.

Sei eix-0.29.6 haben die Optionen B<--verbose> und B<--compact> nur noch Einschalt-Funktion;
zum Ausschalten gibt es die neue Option B<--normal>.

B<eix-functions.sh> konnte früher nur ge-sourced werden; erst sei eix-0.32.2 ist
B<eix-functions.sh> auch ein Programm, dessen Ausgabe für die Benutzung mit "eval" gedacht ist.

Das Ebuild hat viele frühere USE-Flags entfernt, um einer allgemeinen Gentoo-Politik zu folgen.
Der Maintainer empfiehlt daher stark die Benutzung von B<EXTRA_ECONF> zur Installation.
.\" }}}

.\" {{{ ÜBERSETZUNG
.SH "ÜBERSETZUNG"
.LP
Für eine einfache feste Übersetzung des voreingestellten B<FORMATSTRING> in Ihre Sprache,
genügt es die Variablen, die mit I18N_... beginning in B</etc/eixrc> oder B<~/.eixrc> zu setzen:
Leiten Sie die Ausgabe von B<eix --dump-defaults> in eine Datei um, um eine Liste
aller Variablen zu erhalten: Einige der letzten sind diejenigen, die sie suchen,
die mit I18N_.... beginnen.

Die Variablen, die mit I18N_COLUMN_.... beginnen, sind dabei speziell und können
benutzt werden, die Spalten an ein neues Layout anzupassen, das aufgrund abweichender
Länge verschiedener Übersetzungen notwendig sein kann. (Beachten Sie, dass die
Formatierung der Spalten durcheinander geraten kann, wenn Sie für Ihre Übersetzung
keine UT8-Kodierung benutzen!)
SIe können die Default-Werte dieser Variablen in den entsprfechenden
C_COLUMN_....-Variablen ablesen, die in der Nähe stehen (aber die für
Übersetzungszwecke nicht verändert werden sollten).
Normalerweise sollte es genügen, B<I18N_COLUMN_CONTENT> und
B<I18N_INST_COLUMN_CONTENT> auf geeignete Zahlen umzudefinieren.
Um sicherzugehen, dass alle Spalten korrekt sind, sollten Sie am Ende die
Ausgabe der Kommandos

eix -vxe binutils

eix -ve binutils

eix -le binutils -oe sun-jdk

eix -xle binutils

eix -vle binutils

eix -xvle binutils

eix -vle sun-jdk

betrachten.
Hierbei steht binutils für ein B<installiertes> Paket mit B<Slots>, während
sun-jdk für ein B<maskiertes> (mit Erklärung des Grunds in package.mask) steht.

Sobald Sie eine Übersetung fertig haben, können Sie Ihre geänderten Variablen
an den Eix-Maintainer oder eix auf Github schicken, oder noch besser:
Fügen Sie Ihre Sprache der Datei po/LINGUAS hinzu, rufen Sie contrib/make auf,
um eine entsprechende po/*.po-Datei zu erhalten, und fügen Sie Ihre Übersetzung
dieser Datei an jenen Stellen hinzu, die sich auf src/eixrc/def_i18n.cc beziehen.

Natürlich können Sie dabei gerne auch andere Texte dieser Datei übersetzen:
Benutzer können auch für unfertige Übersetzungen der wichtigsten Meldungen dankbar sein!

Sie können Ihre neue po/*.po-Datei dem Eix-Maintainer schicken, oder noch besser:
Sie können Ihre Änderung auf Github mit einem Pull Request machen.
.\" }}}

.\" {{{ AUTOREN
.SH "AUTOREN"
.LP
Hauptautoren des Programms:

Martin Väth <martin at mvath.de> (developer, current maintainer)

Emil Beinroth <emilbeinroth at gmx.net> (developer, previous maintainer)


Wolfgang Frisch <xororand at users.sourceforge.net> (inactive developer, initial author)

Roland Wittmann <linuxcommando at users.sourceforge.net> (inactive developer)

Viele weitere Autoren sind in der Datei B<AUTHORS> zu finden.
.\" }}}

.\" {{{ SIEHE AUCH
.SH "SIEHE AUCH"
.BR portage (5),
.\" Matchalgorithmen
.BR fnmatch (3),
.BR regex (7),
.\" Andere Such-Utilities
.BR emerge (1),
.BR esearch (1),
.BR qsearch (1),
.\" Verwandte Software .. etwa Zeug, das wir benutzen
.BR layman (8)
.LP
Die eix-Homepage I<@PACKAGE_URL@> enthält weitere Informationen und Links.
.\" }}}
.\" vim:set tw=90 expandtab foldenable foldmethod=marker foldlevel=0 :
